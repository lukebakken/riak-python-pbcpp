// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak_dt.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "riak_dt.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MapField_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapField_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MapField_MapFieldType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MapEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtFetchReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtFetchReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtFetchResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtFetchResp_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DtFetchResp_DataType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CounterOp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CounterOp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetOp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetOp_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapUpdate_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MapUpdate_FlagOp_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MapOp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapOp_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtOp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtOp_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtUpdateReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtUpdateReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* DtUpdateResp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DtUpdateResp_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_riak_5fdt_2eproto() {
  protobuf_AddDesc_riak_5fdt_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "riak_dt.proto");
  GOOGLE_CHECK(file != NULL);
  MapField_descriptor_ = file->message_type(0);
  static const int MapField_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapField, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapField, type_),
  };
  MapField_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapField_descriptor_,
      MapField::default_instance_,
      MapField_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapField, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapField, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapField));
  MapField_MapFieldType_descriptor_ = MapField_descriptor_->enum_type(0);
  MapEntry_descriptor_ = file->message_type(1);
  static const int MapEntry_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, field_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, counter_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, set_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, register_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, flag_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, map_value_),
  };
  MapEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapEntry_descriptor_,
      MapEntry::default_instance_,
      MapEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapEntry));
  DtFetchReq_descriptor_ = file->message_type(2);
  static const int DtFetchReq_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, bucket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, r_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, pr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, basic_quorum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, notfound_ok_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, sloppy_quorum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, n_val_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, include_context_),
  };
  DtFetchReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtFetchReq_descriptor_,
      DtFetchReq::default_instance_,
      DtFetchReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtFetchReq));
  DtValue_descriptor_ = file->message_type(3);
  static const int DtValue_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtValue, counter_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtValue, set_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtValue, map_value_),
  };
  DtValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtValue_descriptor_,
      DtValue::default_instance_,
      DtValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtValue));
  DtFetchResp_descriptor_ = file->message_type(4);
  static const int DtFetchResp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchResp, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchResp, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchResp, value_),
  };
  DtFetchResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtFetchResp_descriptor_,
      DtFetchResp::default_instance_,
      DtFetchResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtFetchResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtFetchResp));
  DtFetchResp_DataType_descriptor_ = DtFetchResp_descriptor_->enum_type(0);
  CounterOp_descriptor_ = file->message_type(5);
  static const int CounterOp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CounterOp, increment_),
  };
  CounterOp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CounterOp_descriptor_,
      CounterOp::default_instance_,
      CounterOp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CounterOp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CounterOp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CounterOp));
  SetOp_descriptor_ = file->message_type(6);
  static const int SetOp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, adds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, removes_),
  };
  SetOp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SetOp_descriptor_,
      SetOp::default_instance_,
      SetOp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetOp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SetOp));
  MapUpdate_descriptor_ = file->message_type(7);
  static const int MapUpdate_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, field_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, counter_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, set_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, register_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, flag_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, map_op_),
  };
  MapUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapUpdate_descriptor_,
      MapUpdate::default_instance_,
      MapUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapUpdate));
  MapUpdate_FlagOp_descriptor_ = MapUpdate_descriptor_->enum_type(0);
  MapOp_descriptor_ = file->message_type(8);
  static const int MapOp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapOp, removes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapOp, updates_),
  };
  MapOp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapOp_descriptor_,
      MapOp::default_instance_,
      MapOp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapOp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapOp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapOp));
  DtOp_descriptor_ = file->message_type(9);
  static const int DtOp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtOp, counter_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtOp, set_op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtOp, map_op_),
  };
  DtOp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtOp_descriptor_,
      DtOp::default_instance_,
      DtOp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtOp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtOp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtOp));
  DtUpdateReq_descriptor_ = file->message_type(10);
  static const int DtUpdateReq_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, bucket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, w_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, dw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, pw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, return_body_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, sloppy_quorum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, n_val_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, include_context_),
  };
  DtUpdateReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtUpdateReq_descriptor_,
      DtUpdateReq::default_instance_,
      DtUpdateReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtUpdateReq));
  DtUpdateResp_descriptor_ = file->message_type(11);
  static const int DtUpdateResp_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, counter_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, set_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, map_value_),
  };
  DtUpdateResp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DtUpdateResp_descriptor_,
      DtUpdateResp::default_instance_,
      DtUpdateResp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DtUpdateResp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DtUpdateResp));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_riak_5fdt_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapField_descriptor_, &MapField::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapEntry_descriptor_, &MapEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtFetchReq_descriptor_, &DtFetchReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtValue_descriptor_, &DtValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtFetchResp_descriptor_, &DtFetchResp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CounterOp_descriptor_, &CounterOp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SetOp_descriptor_, &SetOp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapUpdate_descriptor_, &MapUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapOp_descriptor_, &MapOp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtOp_descriptor_, &DtOp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtUpdateReq_descriptor_, &DtUpdateReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DtUpdateResp_descriptor_, &DtUpdateResp::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_riak_5fdt_2eproto() {
  delete MapField::default_instance_;
  delete MapField_reflection_;
  delete MapEntry::default_instance_;
  delete MapEntry_reflection_;
  delete DtFetchReq::default_instance_;
  delete DtFetchReq_reflection_;
  delete DtValue::default_instance_;
  delete DtValue_reflection_;
  delete DtFetchResp::default_instance_;
  delete DtFetchResp_reflection_;
  delete CounterOp::default_instance_;
  delete CounterOp_reflection_;
  delete SetOp::default_instance_;
  delete SetOp_reflection_;
  delete MapUpdate::default_instance_;
  delete MapUpdate_reflection_;
  delete MapOp::default_instance_;
  delete MapOp_reflection_;
  delete DtOp::default_instance_;
  delete DtOp_reflection_;
  delete DtUpdateReq::default_instance_;
  delete DtUpdateReq_reflection_;
  delete DtUpdateResp::default_instance_;
  delete DtUpdateResp_reflection_;
}

void protobuf_AddDesc_riak_5fdt_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rriak_dt.proto\"\205\001\n\010MapField\022\014\n\004name\030\001 \002"
    "(\014\022$\n\004type\030\002 \002(\0162\026.MapField.MapFieldType"
    "\"E\n\014MapFieldType\022\013\n\007COUNTER\020\001\022\007\n\003SET\020\002\022\014"
    "\n\010REGISTER\020\003\022\010\n\004FLAG\020\004\022\007\n\003MAP\020\005\"\230\001\n\010MapE"
    "ntry\022\030\n\005field\030\001 \002(\0132\t.MapField\022\025\n\rcounte"
    "r_value\030\002 \001(\022\022\021\n\tset_value\030\003 \003(\014\022\026\n\016regi"
    "ster_value\030\004 \001(\014\022\022\n\nflag_value\030\005 \001(\010\022\034\n\t"
    "map_value\030\006 \003(\0132\t.MapEntry\"\317\001\n\nDtFetchRe"
    "q\022\016\n\006bucket\030\001 \002(\014\022\013\n\003key\030\002 \002(\014\022\014\n\004type\030\003"
    " \002(\014\022\t\n\001r\030\004 \001(\r\022\n\n\002pr\030\005 \001(\r\022\024\n\014basic_quo"
    "rum\030\006 \001(\010\022\023\n\013notfound_ok\030\007 \001(\010\022\017\n\007timeou"
    "t\030\010 \001(\r\022\025\n\rsloppy_quorum\030\t \001(\010\022\r\n\005n_val\030"
    "\n \001(\r\022\035\n\017include_context\030\013 \001(\010:\004true\"Q\n\007"
    "DtValue\022\025\n\rcounter_value\030\001 \001(\022\022\021\n\tset_va"
    "lue\030\002 \003(\014\022\034\n\tmap_value\030\003 \003(\0132\t.MapEntry\""
    "\207\001\n\013DtFetchResp\022\017\n\007context\030\001 \001(\014\022#\n\004type"
    "\030\002 \002(\0162\025.DtFetchResp.DataType\022\027\n\005value\030\003"
    " \001(\0132\010.DtValue\")\n\010DataType\022\013\n\007COUNTER\020\001\022"
    "\007\n\003SET\020\002\022\007\n\003MAP\020\003\"\036\n\tCounterOp\022\021\n\tincrem"
    "ent\030\001 \001(\022\"&\n\005SetOp\022\014\n\004adds\030\001 \003(\014\022\017\n\007remo"
    "ves\030\002 \003(\014\"\321\001\n\tMapUpdate\022\030\n\005field\030\001 \002(\0132\t"
    ".MapField\022\036\n\ncounter_op\030\002 \001(\0132\n.CounterO"
    "p\022\026\n\006set_op\030\003 \001(\0132\006.SetOp\022\023\n\013register_op"
    "\030\004 \001(\014\022\"\n\007flag_op\030\005 \001(\0162\021.MapUpdate.Flag"
    "Op\022\026\n\006map_op\030\006 \001(\0132\006.MapOp\"!\n\006FlagOp\022\n\n\006"
    "ENABLE\020\001\022\013\n\007DISABLE\020\002\"@\n\005MapOp\022\032\n\007remove"
    "s\030\001 \003(\0132\t.MapField\022\033\n\007updates\030\002 \003(\0132\n.Ma"
    "pUpdate\"V\n\004DtOp\022\036\n\ncounter_op\030\001 \001(\0132\n.Co"
    "unterOp\022\026\n\006set_op\030\002 \001(\0132\006.SetOp\022\026\n\006map_o"
    "p\030\003 \001(\0132\006.MapOp\"\361\001\n\013DtUpdateReq\022\016\n\006bucke"
    "t\030\001 \002(\014\022\013\n\003key\030\002 \001(\014\022\014\n\004type\030\003 \002(\014\022\017\n\007co"
    "ntext\030\004 \001(\014\022\021\n\002op\030\005 \002(\0132\005.DtOp\022\t\n\001w\030\006 \001("
    "\r\022\n\n\002dw\030\007 \001(\r\022\n\n\002pw\030\010 \001(\r\022\032\n\013return_body"
    "\030\t \001(\010:\005false\022\017\n\007timeout\030\n \001(\r\022\025\n\rsloppy"
    "_quorum\030\013 \001(\010\022\r\n\005n_val\030\014 \001(\r\022\035\n\017include_"
    "context\030\r \001(\010:\004true\"t\n\014DtUpdateResp\022\013\n\003k"
    "ey\030\001 \001(\014\022\017\n\007context\030\002 \001(\014\022\025\n\rcounter_val"
    "ue\030\003 \001(\022\022\021\n\tset_value\030\004 \003(\014\022\034\n\tmap_value"
    "\030\005 \003(\0132\t.MapEntryB#\n\027com.basho.riak.prot"
    "obufB\010RiakDtPB", 1574);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "riak_dt.proto", &protobuf_RegisterTypes);
  MapField::default_instance_ = new MapField();
  MapEntry::default_instance_ = new MapEntry();
  DtFetchReq::default_instance_ = new DtFetchReq();
  DtValue::default_instance_ = new DtValue();
  DtFetchResp::default_instance_ = new DtFetchResp();
  CounterOp::default_instance_ = new CounterOp();
  SetOp::default_instance_ = new SetOp();
  MapUpdate::default_instance_ = new MapUpdate();
  MapOp::default_instance_ = new MapOp();
  DtOp::default_instance_ = new DtOp();
  DtUpdateReq::default_instance_ = new DtUpdateReq();
  DtUpdateResp::default_instance_ = new DtUpdateResp();
  MapField::default_instance_->InitAsDefaultInstance();
  MapEntry::default_instance_->InitAsDefaultInstance();
  DtFetchReq::default_instance_->InitAsDefaultInstance();
  DtValue::default_instance_->InitAsDefaultInstance();
  DtFetchResp::default_instance_->InitAsDefaultInstance();
  CounterOp::default_instance_->InitAsDefaultInstance();
  SetOp::default_instance_->InitAsDefaultInstance();
  MapUpdate::default_instance_->InitAsDefaultInstance();
  MapOp::default_instance_->InitAsDefaultInstance();
  DtOp::default_instance_->InitAsDefaultInstance();
  DtUpdateReq::default_instance_->InitAsDefaultInstance();
  DtUpdateResp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_riak_5fdt_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_riak_5fdt_2eproto {
  StaticDescriptorInitializer_riak_5fdt_2eproto() {
    protobuf_AddDesc_riak_5fdt_2eproto();
  }
} static_descriptor_initializer_riak_5fdt_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* MapField_MapFieldType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapField_MapFieldType_descriptor_;
}
bool MapField_MapFieldType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const MapField_MapFieldType MapField::COUNTER;
const MapField_MapFieldType MapField::SET;
const MapField_MapFieldType MapField::REGISTER;
const MapField_MapFieldType MapField::FLAG;
const MapField_MapFieldType MapField::MAP;
const MapField_MapFieldType MapField::MapFieldType_MIN;
const MapField_MapFieldType MapField::MapFieldType_MAX;
const int MapField::MapFieldType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int MapField::kNameFieldNumber;
const int MapField::kTypeFieldNumber;
#endif  // !_MSC_VER

MapField::MapField()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapField)
}

void MapField::InitAsDefaultInstance() {
}

MapField::MapField(const MapField& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MapField)
}

void MapField::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapField::~MapField() {
  // @@protoc_insertion_point(destructor:MapField)
  SharedDtor();
}

void MapField::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void MapField::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapField::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapField_descriptor_;
}

const MapField& MapField::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

MapField* MapField::default_instance_ = NULL;

MapField* MapField::New() const {
  return new MapField;
}

void MapField::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapField::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MapField)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .MapField.MapFieldType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::MapField_MapFieldType_IsValid(value)) {
            set_type(static_cast< ::MapField_MapFieldType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapField)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapField)
  return false;
#undef DO_
}

void MapField::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapField)
  // required bytes name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->name(), output);
  }

  // required .MapField.MapFieldType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MapField)
}

::google::protobuf::uint8* MapField::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MapField)
  // required bytes name = 1;
  if (has_name()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->name(), target);
  }

  // required .MapField.MapFieldType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MapField)
  return target;
}

int MapField::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // required .MapField.MapFieldType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapField::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapField* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapField*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapField::MergeFrom(const MapField& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapField::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapField::CopyFrom(const MapField& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapField::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MapField::Swap(MapField* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapField::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapField_descriptor_;
  metadata.reflection = MapField_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapEntry::kFieldFieldNumber;
const int MapEntry::kCounterValueFieldNumber;
const int MapEntry::kSetValueFieldNumber;
const int MapEntry::kRegisterValueFieldNumber;
const int MapEntry::kFlagValueFieldNumber;
const int MapEntry::kMapValueFieldNumber;
#endif  // !_MSC_VER

MapEntry::MapEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapEntry)
}

void MapEntry::InitAsDefaultInstance() {
  field_ = const_cast< ::MapField*>(&::MapField::default_instance());
}

MapEntry::MapEntry(const MapEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MapEntry)
}

void MapEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  field_ = NULL;
  counter_value_ = GOOGLE_LONGLONG(0);
  register_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flag_value_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapEntry::~MapEntry() {
  // @@protoc_insertion_point(destructor:MapEntry)
  SharedDtor();
}

void MapEntry::SharedDtor() {
  if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_value_;
  }
  if (this != default_instance_) {
    delete field_;
  }
}

void MapEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapEntry_descriptor_;
}

const MapEntry& MapEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

MapEntry* MapEntry::default_instance_ = NULL;

MapEntry* MapEntry::New() const {
  return new MapEntry;
}

void MapEntry::Clear() {
  if (_has_bits_[0 / 32] & 27) {
    if (has_field()) {
      if (field_ != NULL) field_->::MapField::Clear();
    }
    counter_value_ = GOOGLE_LONGLONG(0);
    if (has_register_value()) {
      if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        register_value_->clear();
      }
    }
    flag_value_ = false;
  }
  set_value_.Clear();
  map_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MapEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MapField field = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_counter_value;
        break;
      }

      // optional sint64 counter_value = 2;
      case 2: {
        if (tag == 16) {
         parse_counter_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &counter_value_)));
          set_has_counter_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_set_value;
        break;
      }

      // repeated bytes set_value = 3;
      case 3: {
        if (tag == 26) {
         parse_set_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_set_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_set_value;
        if (input->ExpectTag(34)) goto parse_register_value;
        break;
      }

      // optional bytes register_value = 4;
      case 4: {
        if (tag == 34) {
         parse_register_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_register_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_flag_value;
        break;
      }

      // optional bool flag_value = 5;
      case 5: {
        if (tag == 40) {
         parse_flag_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_value_)));
          set_has_flag_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_map_value;
        break;
      }

      // repeated .MapEntry map_value = 6;
      case 6: {
        if (tag == 50) {
         parse_map_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_map_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_map_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapEntry)
  return false;
#undef DO_
}

void MapEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapEntry)
  // required .MapField field = 1;
  if (has_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field(), output);
  }

  // optional sint64 counter_value = 2;
  if (has_counter_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(2, this->counter_value(), output);
  }

  // repeated bytes set_value = 3;
  for (int i = 0; i < this->set_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->set_value(i), output);
  }

  // optional bytes register_value = 4;
  if (has_register_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->register_value(), output);
  }

  // optional bool flag_value = 5;
  if (has_flag_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->flag_value(), output);
  }

  // repeated .MapEntry map_value = 6;
  for (int i = 0; i < this->map_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->map_value(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MapEntry)
}

::google::protobuf::uint8* MapEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MapEntry)
  // required .MapField field = 1;
  if (has_field()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->field(), target);
  }

  // optional sint64 counter_value = 2;
  if (has_counter_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(2, this->counter_value(), target);
  }

  // repeated bytes set_value = 3;
  for (int i = 0; i < this->set_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->set_value(i), target);
  }

  // optional bytes register_value = 4;
  if (has_register_value()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->register_value(), target);
  }

  // optional bool flag_value = 5;
  if (has_flag_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->flag_value(), target);
  }

  // repeated .MapEntry map_value = 6;
  for (int i = 0; i < this->map_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->map_value(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MapEntry)
  return target;
}

int MapEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MapField field = 1;
    if (has_field()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->field());
    }

    // optional sint64 counter_value = 2;
    if (has_counter_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->counter_value());
    }

    // optional bytes register_value = 4;
    if (has_register_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->register_value());
    }

    // optional bool flag_value = 5;
    if (has_flag_value()) {
      total_size += 1 + 1;
    }

  }
  // repeated bytes set_value = 3;
  total_size += 1 * this->set_value_size();
  for (int i = 0; i < this->set_value_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->set_value(i));
  }

  // repeated .MapEntry map_value = 6;
  total_size += 1 * this->map_value_size();
  for (int i = 0; i < this->map_value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->map_value(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapEntry::MergeFrom(const MapEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  set_value_.MergeFrom(from.set_value_);
  map_value_.MergeFrom(from.map_value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_field()) {
      mutable_field()->::MapField::MergeFrom(from.field());
    }
    if (from.has_counter_value()) {
      set_counter_value(from.counter_value());
    }
    if (from.has_register_value()) {
      set_register_value(from.register_value());
    }
    if (from.has_flag_value()) {
      set_flag_value(from.flag_value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapEntry::CopyFrom(const MapEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_field()) {
    if (!this->field().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->map_value())) return false;
  return true;
}

void MapEntry::Swap(MapEntry* other) {
  if (other != this) {
    std::swap(field_, other->field_);
    std::swap(counter_value_, other->counter_value_);
    set_value_.Swap(&other->set_value_);
    std::swap(register_value_, other->register_value_);
    std::swap(flag_value_, other->flag_value_);
    map_value_.Swap(&other->map_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapEntry_descriptor_;
  metadata.reflection = MapEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DtFetchReq::kBucketFieldNumber;
const int DtFetchReq::kKeyFieldNumber;
const int DtFetchReq::kTypeFieldNumber;
const int DtFetchReq::kRFieldNumber;
const int DtFetchReq::kPrFieldNumber;
const int DtFetchReq::kBasicQuorumFieldNumber;
const int DtFetchReq::kNotfoundOkFieldNumber;
const int DtFetchReq::kTimeoutFieldNumber;
const int DtFetchReq::kSloppyQuorumFieldNumber;
const int DtFetchReq::kNValFieldNumber;
const int DtFetchReq::kIncludeContextFieldNumber;
#endif  // !_MSC_VER

DtFetchReq::DtFetchReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtFetchReq)
}

void DtFetchReq::InitAsDefaultInstance() {
}

DtFetchReq::DtFetchReq(const DtFetchReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtFetchReq)
}

void DtFetchReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  r_ = 0u;
  pr_ = 0u;
  basic_quorum_ = false;
  notfound_ok_ = false;
  timeout_ = 0u;
  sloppy_quorum_ = false;
  n_val_ = 0u;
  include_context_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtFetchReq::~DtFetchReq() {
  // @@protoc_insertion_point(destructor:DtFetchReq)
  SharedDtor();
}

void DtFetchReq::SharedDtor() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (this != default_instance_) {
  }
}

void DtFetchReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtFetchReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtFetchReq_descriptor_;
}

const DtFetchReq& DtFetchReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtFetchReq* DtFetchReq::default_instance_ = NULL;

DtFetchReq* DtFetchReq::New() const {
  return new DtFetchReq;
}

void DtFetchReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DtFetchReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(r_, notfound_ok_);
    if (has_bucket()) {
      if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        bucket_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 1792) {
    sloppy_quorum_ = false;
    n_val_ = 0u;
    include_context_ = true;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtFetchReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtFetchReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes bucket = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bucket()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // required bytes key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_type;
        break;
      }

      // required bytes type = 3;
      case 3: {
        if (tag == 26) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_r;
        break;
      }

      // optional uint32 r = 4;
      case 4: {
        if (tag == 32) {
         parse_r:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_)));
          set_has_r();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pr;
        break;
      }

      // optional uint32 pr = 5;
      case 5: {
        if (tag == 40) {
         parse_pr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pr_)));
          set_has_pr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_basic_quorum;
        break;
      }

      // optional bool basic_quorum = 6;
      case 6: {
        if (tag == 48) {
         parse_basic_quorum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &basic_quorum_)));
          set_has_basic_quorum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_notfound_ok;
        break;
      }

      // optional bool notfound_ok = 7;
      case 7: {
        if (tag == 56) {
         parse_notfound_ok:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &notfound_ok_)));
          set_has_notfound_ok();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_timeout;
        break;
      }

      // optional uint32 timeout = 8;
      case 8: {
        if (tag == 64) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeout_)));
          set_has_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_sloppy_quorum;
        break;
      }

      // optional bool sloppy_quorum = 9;
      case 9: {
        if (tag == 72) {
         parse_sloppy_quorum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sloppy_quorum_)));
          set_has_sloppy_quorum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_n_val;
        break;
      }

      // optional uint32 n_val = 10;
      case 10: {
        if (tag == 80) {
         parse_n_val:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_val_)));
          set_has_n_val();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_include_context;
        break;
      }

      // optional bool include_context = 11 [default = true];
      case 11: {
        if (tag == 88) {
         parse_include_context:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_context_)));
          set_has_include_context();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtFetchReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtFetchReq)
  return false;
#undef DO_
}

void DtFetchReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtFetchReq)
  // required bytes bucket = 1;
  if (has_bucket()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->bucket(), output);
  }

  // required bytes key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  // required bytes type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->type(), output);
  }

  // optional uint32 r = 4;
  if (has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->r(), output);
  }

  // optional uint32 pr = 5;
  if (has_pr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->pr(), output);
  }

  // optional bool basic_quorum = 6;
  if (has_basic_quorum()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->basic_quorum(), output);
  }

  // optional bool notfound_ok = 7;
  if (has_notfound_ok()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->notfound_ok(), output);
  }

  // optional uint32 timeout = 8;
  if (has_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->timeout(), output);
  }

  // optional bool sloppy_quorum = 9;
  if (has_sloppy_quorum()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->sloppy_quorum(), output);
  }

  // optional uint32 n_val = 10;
  if (has_n_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->n_val(), output);
  }

  // optional bool include_context = 11 [default = true];
  if (has_include_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->include_context(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtFetchReq)
}

::google::protobuf::uint8* DtFetchReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtFetchReq)
  // required bytes bucket = 1;
  if (has_bucket()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->bucket(), target);
  }

  // required bytes key = 2;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  // required bytes type = 3;
  if (has_type()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->type(), target);
  }

  // optional uint32 r = 4;
  if (has_r()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->r(), target);
  }

  // optional uint32 pr = 5;
  if (has_pr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->pr(), target);
  }

  // optional bool basic_quorum = 6;
  if (has_basic_quorum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->basic_quorum(), target);
  }

  // optional bool notfound_ok = 7;
  if (has_notfound_ok()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->notfound_ok(), target);
  }

  // optional uint32 timeout = 8;
  if (has_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->timeout(), target);
  }

  // optional bool sloppy_quorum = 9;
  if (has_sloppy_quorum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->sloppy_quorum(), target);
  }

  // optional uint32 n_val = 10;
  if (has_n_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->n_val(), target);
  }

  // optional bool include_context = 11 [default = true];
  if (has_include_context()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->include_context(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtFetchReq)
  return target;
}

int DtFetchReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes bucket = 1;
    if (has_bucket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bucket());
    }

    // required bytes key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // required bytes type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->type());
    }

    // optional uint32 r = 4;
    if (has_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r());
    }

    // optional uint32 pr = 5;
    if (has_pr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pr());
    }

    // optional bool basic_quorum = 6;
    if (has_basic_quorum()) {
      total_size += 1 + 1;
    }

    // optional bool notfound_ok = 7;
    if (has_notfound_ok()) {
      total_size += 1 + 1;
    }

    // optional uint32 timeout = 8;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeout());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool sloppy_quorum = 9;
    if (has_sloppy_quorum()) {
      total_size += 1 + 1;
    }

    // optional uint32 n_val = 10;
    if (has_n_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_val());
    }

    // optional bool include_context = 11 [default = true];
    if (has_include_context()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtFetchReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtFetchReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtFetchReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtFetchReq::MergeFrom(const DtFetchReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bucket()) {
      set_bucket(from.bucket());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_r()) {
      set_r(from.r());
    }
    if (from.has_pr()) {
      set_pr(from.pr());
    }
    if (from.has_basic_quorum()) {
      set_basic_quorum(from.basic_quorum());
    }
    if (from.has_notfound_ok()) {
      set_notfound_ok(from.notfound_ok());
    }
    if (from.has_timeout()) {
      set_timeout(from.timeout());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sloppy_quorum()) {
      set_sloppy_quorum(from.sloppy_quorum());
    }
    if (from.has_n_val()) {
      set_n_val(from.n_val());
    }
    if (from.has_include_context()) {
      set_include_context(from.include_context());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtFetchReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtFetchReq::CopyFrom(const DtFetchReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtFetchReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void DtFetchReq::Swap(DtFetchReq* other) {
  if (other != this) {
    std::swap(bucket_, other->bucket_);
    std::swap(key_, other->key_);
    std::swap(type_, other->type_);
    std::swap(r_, other->r_);
    std::swap(pr_, other->pr_);
    std::swap(basic_quorum_, other->basic_quorum_);
    std::swap(notfound_ok_, other->notfound_ok_);
    std::swap(timeout_, other->timeout_);
    std::swap(sloppy_quorum_, other->sloppy_quorum_);
    std::swap(n_val_, other->n_val_);
    std::swap(include_context_, other->include_context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtFetchReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtFetchReq_descriptor_;
  metadata.reflection = DtFetchReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DtValue::kCounterValueFieldNumber;
const int DtValue::kSetValueFieldNumber;
const int DtValue::kMapValueFieldNumber;
#endif  // !_MSC_VER

DtValue::DtValue()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtValue)
}

void DtValue::InitAsDefaultInstance() {
}

DtValue::DtValue(const DtValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtValue)
}

void DtValue::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  counter_value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtValue::~DtValue() {
  // @@protoc_insertion_point(destructor:DtValue)
  SharedDtor();
}

void DtValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DtValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtValue_descriptor_;
}

const DtValue& DtValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtValue* DtValue::default_instance_ = NULL;

DtValue* DtValue::New() const {
  return new DtValue;
}

void DtValue::Clear() {
  counter_value_ = GOOGLE_LONGLONG(0);
  set_value_.Clear();
  map_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint64 counter_value = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &counter_value_)));
          set_has_counter_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_set_value;
        break;
      }

      // repeated bytes set_value = 2;
      case 2: {
        if (tag == 18) {
         parse_set_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_set_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_set_value;
        if (input->ExpectTag(26)) goto parse_map_value;
        break;
      }

      // repeated .MapEntry map_value = 3;
      case 3: {
        if (tag == 26) {
         parse_map_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_map_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_map_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtValue)
  return false;
#undef DO_
}

void DtValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtValue)
  // optional sint64 counter_value = 1;
  if (has_counter_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(1, this->counter_value(), output);
  }

  // repeated bytes set_value = 2;
  for (int i = 0; i < this->set_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->set_value(i), output);
  }

  // repeated .MapEntry map_value = 3;
  for (int i = 0; i < this->map_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->map_value(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtValue)
}

::google::protobuf::uint8* DtValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtValue)
  // optional sint64 counter_value = 1;
  if (has_counter_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(1, this->counter_value(), target);
  }

  // repeated bytes set_value = 2;
  for (int i = 0; i < this->set_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->set_value(i), target);
  }

  // repeated .MapEntry map_value = 3;
  for (int i = 0; i < this->map_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->map_value(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtValue)
  return target;
}

int DtValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint64 counter_value = 1;
    if (has_counter_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->counter_value());
    }

  }
  // repeated bytes set_value = 2;
  total_size += 1 * this->set_value_size();
  for (int i = 0; i < this->set_value_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->set_value(i));
  }

  // repeated .MapEntry map_value = 3;
  total_size += 1 * this->map_value_size();
  for (int i = 0; i < this->map_value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->map_value(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtValue::MergeFrom(const DtValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  set_value_.MergeFrom(from.set_value_);
  map_value_.MergeFrom(from.map_value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_counter_value()) {
      set_counter_value(from.counter_value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtValue::CopyFrom(const DtValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtValue::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->map_value())) return false;
  return true;
}

void DtValue::Swap(DtValue* other) {
  if (other != this) {
    std::swap(counter_value_, other->counter_value_);
    set_value_.Swap(&other->set_value_);
    map_value_.Swap(&other->map_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtValue_descriptor_;
  metadata.reflection = DtValue_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DtFetchResp_DataType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtFetchResp_DataType_descriptor_;
}
bool DtFetchResp_DataType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DtFetchResp_DataType DtFetchResp::COUNTER;
const DtFetchResp_DataType DtFetchResp::SET;
const DtFetchResp_DataType DtFetchResp::MAP;
const DtFetchResp_DataType DtFetchResp::DataType_MIN;
const DtFetchResp_DataType DtFetchResp::DataType_MAX;
const int DtFetchResp::DataType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DtFetchResp::kContextFieldNumber;
const int DtFetchResp::kTypeFieldNumber;
const int DtFetchResp::kValueFieldNumber;
#endif  // !_MSC_VER

DtFetchResp::DtFetchResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtFetchResp)
}

void DtFetchResp::InitAsDefaultInstance() {
  value_ = const_cast< ::DtValue*>(&::DtValue::default_instance());
}

DtFetchResp::DtFetchResp(const DtFetchResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtFetchResp)
}

void DtFetchResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtFetchResp::~DtFetchResp() {
  // @@protoc_insertion_point(destructor:DtFetchResp)
  SharedDtor();
}

void DtFetchResp::SharedDtor() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (this != default_instance_) {
    delete value_;
  }
}

void DtFetchResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtFetchResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtFetchResp_descriptor_;
}

const DtFetchResp& DtFetchResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtFetchResp* DtFetchResp::default_instance_ = NULL;

DtFetchResp* DtFetchResp::New() const {
  return new DtFetchResp;
}

void DtFetchResp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        context_->clear();
      }
    }
    type_ = 1;
    if (has_value()) {
      if (value_ != NULL) value_->::DtValue::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtFetchResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtFetchResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes context = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_context()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .DtFetchResp.DataType type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DtFetchResp_DataType_IsValid(value)) {
            set_type(static_cast< ::DtFetchResp_DataType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .DtValue value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtFetchResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtFetchResp)
  return false;
#undef DO_
}

void DtFetchResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtFetchResp)
  // optional bytes context = 1;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->context(), output);
  }

  // required .DtFetchResp.DataType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .DtValue value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtFetchResp)
}

::google::protobuf::uint8* DtFetchResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtFetchResp)
  // optional bytes context = 1;
  if (has_context()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->context(), target);
  }

  // required .DtFetchResp.DataType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .DtValue value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtFetchResp)
  return target;
}

int DtFetchResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes context = 1;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->context());
    }

    // required .DtFetchResp.DataType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .DtValue value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtFetchResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtFetchResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtFetchResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtFetchResp::MergeFrom(const DtFetchResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      mutable_value()->::DtValue::MergeFrom(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtFetchResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtFetchResp::CopyFrom(const DtFetchResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtFetchResp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void DtFetchResp::Swap(DtFetchResp* other) {
  if (other != this) {
    std::swap(context_, other->context_);
    std::swap(type_, other->type_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtFetchResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtFetchResp_descriptor_;
  metadata.reflection = DtFetchResp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CounterOp::kIncrementFieldNumber;
#endif  // !_MSC_VER

CounterOp::CounterOp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CounterOp)
}

void CounterOp::InitAsDefaultInstance() {
}

CounterOp::CounterOp(const CounterOp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CounterOp)
}

void CounterOp::SharedCtor() {
  _cached_size_ = 0;
  increment_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CounterOp::~CounterOp() {
  // @@protoc_insertion_point(destructor:CounterOp)
  SharedDtor();
}

void CounterOp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CounterOp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CounterOp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CounterOp_descriptor_;
}

const CounterOp& CounterOp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

CounterOp* CounterOp::default_instance_ = NULL;

CounterOp* CounterOp::New() const {
  return new CounterOp;
}

void CounterOp::Clear() {
  increment_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CounterOp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CounterOp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint64 increment = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &increment_)));
          set_has_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CounterOp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CounterOp)
  return false;
#undef DO_
}

void CounterOp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CounterOp)
  // optional sint64 increment = 1;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(1, this->increment(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CounterOp)
}

::google::protobuf::uint8* CounterOp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CounterOp)
  // optional sint64 increment = 1;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(1, this->increment(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CounterOp)
  return target;
}

int CounterOp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint64 increment = 1;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->increment());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CounterOp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CounterOp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CounterOp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CounterOp::MergeFrom(const CounterOp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_increment()) {
      set_increment(from.increment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CounterOp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CounterOp::CopyFrom(const CounterOp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterOp::IsInitialized() const {

  return true;
}

void CounterOp::Swap(CounterOp* other) {
  if (other != this) {
    std::swap(increment_, other->increment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CounterOp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CounterOp_descriptor_;
  metadata.reflection = CounterOp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SetOp::kAddsFieldNumber;
const int SetOp::kRemovesFieldNumber;
#endif  // !_MSC_VER

SetOp::SetOp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SetOp)
}

void SetOp::InitAsDefaultInstance() {
}

SetOp::SetOp(const SetOp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:SetOp)
}

void SetOp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetOp::~SetOp() {
  // @@protoc_insertion_point(destructor:SetOp)
  SharedDtor();
}

void SetOp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SetOp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetOp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetOp_descriptor_;
}

const SetOp& SetOp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

SetOp* SetOp::default_instance_ = NULL;

SetOp* SetOp::New() const {
  return new SetOp;
}

void SetOp::Clear() {
  adds_.Clear();
  removes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SetOp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:SetOp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes adds = 1;
      case 1: {
        if (tag == 10) {
         parse_adds:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_adds()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_adds;
        if (input->ExpectTag(18)) goto parse_removes;
        break;
      }

      // repeated bytes removes = 2;
      case 2: {
        if (tag == 18) {
         parse_removes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_removes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_removes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SetOp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SetOp)
  return false;
#undef DO_
}

void SetOp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SetOp)
  // repeated bytes adds = 1;
  for (int i = 0; i < this->adds_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->adds(i), output);
  }

  // repeated bytes removes = 2;
  for (int i = 0; i < this->removes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->removes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SetOp)
}

::google::protobuf::uint8* SetOp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SetOp)
  // repeated bytes adds = 1;
  for (int i = 0; i < this->adds_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->adds(i), target);
  }

  // repeated bytes removes = 2;
  for (int i = 0; i < this->removes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->removes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SetOp)
  return target;
}

int SetOp::ByteSize() const {
  int total_size = 0;

  // repeated bytes adds = 1;
  total_size += 1 * this->adds_size();
  for (int i = 0; i < this->adds_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->adds(i));
  }

  // repeated bytes removes = 2;
  total_size += 1 * this->removes_size();
  for (int i = 0; i < this->removes_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->removes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetOp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SetOp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SetOp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SetOp::MergeFrom(const SetOp& from) {
  GOOGLE_CHECK_NE(&from, this);
  adds_.MergeFrom(from.adds_);
  removes_.MergeFrom(from.removes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SetOp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetOp::CopyFrom(const SetOp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetOp::IsInitialized() const {

  return true;
}

void SetOp::Swap(SetOp* other) {
  if (other != this) {
    adds_.Swap(&other->adds_);
    removes_.Swap(&other->removes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SetOp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetOp_descriptor_;
  metadata.reflection = SetOp_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* MapUpdate_FlagOp_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapUpdate_FlagOp_descriptor_;
}
bool MapUpdate_FlagOp_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const MapUpdate_FlagOp MapUpdate::ENABLE;
const MapUpdate_FlagOp MapUpdate::DISABLE;
const MapUpdate_FlagOp MapUpdate::FlagOp_MIN;
const MapUpdate_FlagOp MapUpdate::FlagOp_MAX;
const int MapUpdate::FlagOp_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int MapUpdate::kFieldFieldNumber;
const int MapUpdate::kCounterOpFieldNumber;
const int MapUpdate::kSetOpFieldNumber;
const int MapUpdate::kRegisterOpFieldNumber;
const int MapUpdate::kFlagOpFieldNumber;
const int MapUpdate::kMapOpFieldNumber;
#endif  // !_MSC_VER

MapUpdate::MapUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapUpdate)
}

void MapUpdate::InitAsDefaultInstance() {
  field_ = const_cast< ::MapField*>(&::MapField::default_instance());
  counter_op_ = const_cast< ::CounterOp*>(&::CounterOp::default_instance());
  set_op_ = const_cast< ::SetOp*>(&::SetOp::default_instance());
  map_op_ = const_cast< ::MapOp*>(&::MapOp::default_instance());
}

MapUpdate::MapUpdate(const MapUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MapUpdate)
}

void MapUpdate::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  field_ = NULL;
  counter_op_ = NULL;
  set_op_ = NULL;
  register_op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flag_op_ = 1;
  map_op_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapUpdate::~MapUpdate() {
  // @@protoc_insertion_point(destructor:MapUpdate)
  SharedDtor();
}

void MapUpdate::SharedDtor() {
  if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_op_;
  }
  if (this != default_instance_) {
    delete field_;
    delete counter_op_;
    delete set_op_;
    delete map_op_;
  }
}

void MapUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapUpdate_descriptor_;
}

const MapUpdate& MapUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

MapUpdate* MapUpdate::default_instance_ = NULL;

MapUpdate* MapUpdate::New() const {
  return new MapUpdate;
}

void MapUpdate::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_field()) {
      if (field_ != NULL) field_->::MapField::Clear();
    }
    if (has_counter_op()) {
      if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
    }
    if (has_set_op()) {
      if (set_op_ != NULL) set_op_->::SetOp::Clear();
    }
    if (has_register_op()) {
      if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        register_op_->clear();
      }
    }
    flag_op_ = 1;
    if (has_map_op()) {
      if (map_op_ != NULL) map_op_->::MapOp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MapUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MapField field = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_counter_op;
        break;
      }

      // optional .CounterOp counter_op = 2;
      case 2: {
        if (tag == 18) {
         parse_counter_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_counter_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_set_op;
        break;
      }

      // optional .SetOp set_op = 3;
      case 3: {
        if (tag == 26) {
         parse_set_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_register_op;
        break;
      }

      // optional bytes register_op = 4;
      case 4: {
        if (tag == 34) {
         parse_register_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_register_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_flag_op;
        break;
      }

      // optional .MapUpdate.FlagOp flag_op = 5;
      case 5: {
        if (tag == 40) {
         parse_flag_op:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::MapUpdate_FlagOp_IsValid(value)) {
            set_flag_op(static_cast< ::MapUpdate_FlagOp >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_map_op;
        break;
      }

      // optional .MapOp map_op = 6;
      case 6: {
        if (tag == 50) {
         parse_map_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapUpdate)
  return false;
#undef DO_
}

void MapUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapUpdate)
  // required .MapField field = 1;
  if (has_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field(), output);
  }

  // optional .CounterOp counter_op = 2;
  if (has_counter_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->counter_op(), output);
  }

  // optional .SetOp set_op = 3;
  if (has_set_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->set_op(), output);
  }

  // optional bytes register_op = 4;
  if (has_register_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->register_op(), output);
  }

  // optional .MapUpdate.FlagOp flag_op = 5;
  if (has_flag_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->flag_op(), output);
  }

  // optional .MapOp map_op = 6;
  if (has_map_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->map_op(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MapUpdate)
}

::google::protobuf::uint8* MapUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MapUpdate)
  // required .MapField field = 1;
  if (has_field()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->field(), target);
  }

  // optional .CounterOp counter_op = 2;
  if (has_counter_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->counter_op(), target);
  }

  // optional .SetOp set_op = 3;
  if (has_set_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->set_op(), target);
  }

  // optional bytes register_op = 4;
  if (has_register_op()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->register_op(), target);
  }

  // optional .MapUpdate.FlagOp flag_op = 5;
  if (has_flag_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->flag_op(), target);
  }

  // optional .MapOp map_op = 6;
  if (has_map_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->map_op(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MapUpdate)
  return target;
}

int MapUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MapField field = 1;
    if (has_field()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->field());
    }

    // optional .CounterOp counter_op = 2;
    if (has_counter_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->counter_op());
    }

    // optional .SetOp set_op = 3;
    if (has_set_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->set_op());
    }

    // optional bytes register_op = 4;
    if (has_register_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->register_op());
    }

    // optional .MapUpdate.FlagOp flag_op = 5;
    if (has_flag_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag_op());
    }

    // optional .MapOp map_op = 6;
    if (has_map_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->map_op());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapUpdate::MergeFrom(const MapUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_field()) {
      mutable_field()->::MapField::MergeFrom(from.field());
    }
    if (from.has_counter_op()) {
      mutable_counter_op()->::CounterOp::MergeFrom(from.counter_op());
    }
    if (from.has_set_op()) {
      mutable_set_op()->::SetOp::MergeFrom(from.set_op());
    }
    if (from.has_register_op()) {
      set_register_op(from.register_op());
    }
    if (from.has_flag_op()) {
      set_flag_op(from.flag_op());
    }
    if (from.has_map_op()) {
      mutable_map_op()->::MapOp::MergeFrom(from.map_op());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapUpdate::CopyFrom(const MapUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_field()) {
    if (!this->field().IsInitialized()) return false;
  }
  if (has_map_op()) {
    if (!this->map_op().IsInitialized()) return false;
  }
  return true;
}

void MapUpdate::Swap(MapUpdate* other) {
  if (other != this) {
    std::swap(field_, other->field_);
    std::swap(counter_op_, other->counter_op_);
    std::swap(set_op_, other->set_op_);
    std::swap(register_op_, other->register_op_);
    std::swap(flag_op_, other->flag_op_);
    std::swap(map_op_, other->map_op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapUpdate_descriptor_;
  metadata.reflection = MapUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapOp::kRemovesFieldNumber;
const int MapOp::kUpdatesFieldNumber;
#endif  // !_MSC_VER

MapOp::MapOp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapOp)
}

void MapOp::InitAsDefaultInstance() {
}

MapOp::MapOp(const MapOp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MapOp)
}

void MapOp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapOp::~MapOp() {
  // @@protoc_insertion_point(destructor:MapOp)
  SharedDtor();
}

void MapOp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapOp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapOp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapOp_descriptor_;
}

const MapOp& MapOp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

MapOp* MapOp::default_instance_ = NULL;

MapOp* MapOp::New() const {
  return new MapOp;
}

void MapOp::Clear() {
  removes_.Clear();
  updates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapOp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MapOp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapField removes = 1;
      case 1: {
        if (tag == 10) {
         parse_removes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_removes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_removes;
        if (input->ExpectTag(18)) goto parse_updates;
        break;
      }

      // repeated .MapUpdate updates = 2;
      case 2: {
        if (tag == 18) {
         parse_updates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_updates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_updates;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapOp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapOp)
  return false;
#undef DO_
}

void MapOp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapOp)
  // repeated .MapField removes = 1;
  for (int i = 0; i < this->removes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->removes(i), output);
  }

  // repeated .MapUpdate updates = 2;
  for (int i = 0; i < this->updates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->updates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MapOp)
}

::google::protobuf::uint8* MapOp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MapOp)
  // repeated .MapField removes = 1;
  for (int i = 0; i < this->removes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->removes(i), target);
  }

  // repeated .MapUpdate updates = 2;
  for (int i = 0; i < this->updates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->updates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MapOp)
  return target;
}

int MapOp::ByteSize() const {
  int total_size = 0;

  // repeated .MapField removes = 1;
  total_size += 1 * this->removes_size();
  for (int i = 0; i < this->removes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->removes(i));
  }

  // repeated .MapUpdate updates = 2;
  total_size += 1 * this->updates_size();
  for (int i = 0; i < this->updates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->updates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapOp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapOp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapOp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapOp::MergeFrom(const MapOp& from) {
  GOOGLE_CHECK_NE(&from, this);
  removes_.MergeFrom(from.removes_);
  updates_.MergeFrom(from.updates_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapOp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapOp::CopyFrom(const MapOp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapOp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->removes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->updates())) return false;
  return true;
}

void MapOp::Swap(MapOp* other) {
  if (other != this) {
    removes_.Swap(&other->removes_);
    updates_.Swap(&other->updates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapOp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapOp_descriptor_;
  metadata.reflection = MapOp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DtOp::kCounterOpFieldNumber;
const int DtOp::kSetOpFieldNumber;
const int DtOp::kMapOpFieldNumber;
#endif  // !_MSC_VER

DtOp::DtOp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtOp)
}

void DtOp::InitAsDefaultInstance() {
  counter_op_ = const_cast< ::CounterOp*>(&::CounterOp::default_instance());
  set_op_ = const_cast< ::SetOp*>(&::SetOp::default_instance());
  map_op_ = const_cast< ::MapOp*>(&::MapOp::default_instance());
}

DtOp::DtOp(const DtOp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtOp)
}

void DtOp::SharedCtor() {
  _cached_size_ = 0;
  counter_op_ = NULL;
  set_op_ = NULL;
  map_op_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtOp::~DtOp() {
  // @@protoc_insertion_point(destructor:DtOp)
  SharedDtor();
}

void DtOp::SharedDtor() {
  if (this != default_instance_) {
    delete counter_op_;
    delete set_op_;
    delete map_op_;
  }
}

void DtOp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtOp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtOp_descriptor_;
}

const DtOp& DtOp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtOp* DtOp::default_instance_ = NULL;

DtOp* DtOp::New() const {
  return new DtOp;
}

void DtOp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_counter_op()) {
      if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
    }
    if (has_set_op()) {
      if (set_op_ != NULL) set_op_->::SetOp::Clear();
    }
    if (has_map_op()) {
      if (map_op_ != NULL) map_op_->::MapOp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtOp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtOp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CounterOp counter_op = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_counter_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_set_op;
        break;
      }

      // optional .SetOp set_op = 2;
      case 2: {
        if (tag == 18) {
         parse_set_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_map_op;
        break;
      }

      // optional .MapOp map_op = 3;
      case 3: {
        if (tag == 26) {
         parse_map_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtOp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtOp)
  return false;
#undef DO_
}

void DtOp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtOp)
  // optional .CounterOp counter_op = 1;
  if (has_counter_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->counter_op(), output);
  }

  // optional .SetOp set_op = 2;
  if (has_set_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->set_op(), output);
  }

  // optional .MapOp map_op = 3;
  if (has_map_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->map_op(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtOp)
}

::google::protobuf::uint8* DtOp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtOp)
  // optional .CounterOp counter_op = 1;
  if (has_counter_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->counter_op(), target);
  }

  // optional .SetOp set_op = 2;
  if (has_set_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->set_op(), target);
  }

  // optional .MapOp map_op = 3;
  if (has_map_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->map_op(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtOp)
  return target;
}

int DtOp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CounterOp counter_op = 1;
    if (has_counter_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->counter_op());
    }

    // optional .SetOp set_op = 2;
    if (has_set_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->set_op());
    }

    // optional .MapOp map_op = 3;
    if (has_map_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->map_op());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtOp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtOp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtOp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtOp::MergeFrom(const DtOp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_counter_op()) {
      mutable_counter_op()->::CounterOp::MergeFrom(from.counter_op());
    }
    if (from.has_set_op()) {
      mutable_set_op()->::SetOp::MergeFrom(from.set_op());
    }
    if (from.has_map_op()) {
      mutable_map_op()->::MapOp::MergeFrom(from.map_op());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtOp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtOp::CopyFrom(const DtOp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtOp::IsInitialized() const {

  if (has_map_op()) {
    if (!this->map_op().IsInitialized()) return false;
  }
  return true;
}

void DtOp::Swap(DtOp* other) {
  if (other != this) {
    std::swap(counter_op_, other->counter_op_);
    std::swap(set_op_, other->set_op_);
    std::swap(map_op_, other->map_op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtOp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtOp_descriptor_;
  metadata.reflection = DtOp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DtUpdateReq::kBucketFieldNumber;
const int DtUpdateReq::kKeyFieldNumber;
const int DtUpdateReq::kTypeFieldNumber;
const int DtUpdateReq::kContextFieldNumber;
const int DtUpdateReq::kOpFieldNumber;
const int DtUpdateReq::kWFieldNumber;
const int DtUpdateReq::kDwFieldNumber;
const int DtUpdateReq::kPwFieldNumber;
const int DtUpdateReq::kReturnBodyFieldNumber;
const int DtUpdateReq::kTimeoutFieldNumber;
const int DtUpdateReq::kSloppyQuorumFieldNumber;
const int DtUpdateReq::kNValFieldNumber;
const int DtUpdateReq::kIncludeContextFieldNumber;
#endif  // !_MSC_VER

DtUpdateReq::DtUpdateReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtUpdateReq)
}

void DtUpdateReq::InitAsDefaultInstance() {
  op_ = const_cast< ::DtOp*>(&::DtOp::default_instance());
}

DtUpdateReq::DtUpdateReq(const DtUpdateReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtUpdateReq)
}

void DtUpdateReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  op_ = NULL;
  w_ = 0u;
  dw_ = 0u;
  pw_ = 0u;
  return_body_ = false;
  timeout_ = 0u;
  sloppy_quorum_ = false;
  n_val_ = 0u;
  include_context_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtUpdateReq::~DtUpdateReq() {
  // @@protoc_insertion_point(destructor:DtUpdateReq)
  SharedDtor();
}

void DtUpdateReq::SharedDtor() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (this != default_instance_) {
    delete op_;
  }
}

void DtUpdateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtUpdateReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtUpdateReq_descriptor_;
}

const DtUpdateReq& DtUpdateReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtUpdateReq* DtUpdateReq::default_instance_ = NULL;

DtUpdateReq* DtUpdateReq::New() const {
  return new DtUpdateReq;
}

void DtUpdateReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DtUpdateReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(w_, pw_);
    if (has_bucket()) {
      if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        bucket_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        context_->clear();
      }
    }
    if (has_op()) {
      if (op_ != NULL) op_->::DtOp::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(timeout_, sloppy_quorum_);
    n_val_ = 0u;
    include_context_ = true;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtUpdateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtUpdateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes bucket = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bucket()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional bytes key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_type;
        break;
      }

      // required bytes type = 3;
      case 3: {
        if (tag == 26) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_context;
        break;
      }

      // optional bytes context = 4;
      case 4: {
        if (tag == 34) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_context()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_op;
        break;
      }

      // required .DtOp op = 5;
      case 5: {
        if (tag == 42) {
         parse_op:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_w;
        break;
      }

      // optional uint32 w = 6;
      case 6: {
        if (tag == 48) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &w_)));
          set_has_w();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_dw;
        break;
      }

      // optional uint32 dw = 7;
      case 7: {
        if (tag == 56) {
         parse_dw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dw_)));
          set_has_dw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_pw;
        break;
      }

      // optional uint32 pw = 8;
      case 8: {
        if (tag == 64) {
         parse_pw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pw_)));
          set_has_pw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_return_body;
        break;
      }

      // optional bool return_body = 9 [default = false];
      case 9: {
        if (tag == 72) {
         parse_return_body:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &return_body_)));
          set_has_return_body();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_timeout;
        break;
      }

      // optional uint32 timeout = 10;
      case 10: {
        if (tag == 80) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeout_)));
          set_has_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_sloppy_quorum;
        break;
      }

      // optional bool sloppy_quorum = 11;
      case 11: {
        if (tag == 88) {
         parse_sloppy_quorum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sloppy_quorum_)));
          set_has_sloppy_quorum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_n_val;
        break;
      }

      // optional uint32 n_val = 12;
      case 12: {
        if (tag == 96) {
         parse_n_val:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_val_)));
          set_has_n_val();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_include_context;
        break;
      }

      // optional bool include_context = 13 [default = true];
      case 13: {
        if (tag == 104) {
         parse_include_context:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_context_)));
          set_has_include_context();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtUpdateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtUpdateReq)
  return false;
#undef DO_
}

void DtUpdateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtUpdateReq)
  // required bytes bucket = 1;
  if (has_bucket()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->bucket(), output);
  }

  // optional bytes key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->key(), output);
  }

  // required bytes type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->type(), output);
  }

  // optional bytes context = 4;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->context(), output);
  }

  // required .DtOp op = 5;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->op(), output);
  }

  // optional uint32 w = 6;
  if (has_w()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->w(), output);
  }

  // optional uint32 dw = 7;
  if (has_dw()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->dw(), output);
  }

  // optional uint32 pw = 8;
  if (has_pw()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->pw(), output);
  }

  // optional bool return_body = 9 [default = false];
  if (has_return_body()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->return_body(), output);
  }

  // optional uint32 timeout = 10;
  if (has_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->timeout(), output);
  }

  // optional bool sloppy_quorum = 11;
  if (has_sloppy_quorum()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->sloppy_quorum(), output);
  }

  // optional uint32 n_val = 12;
  if (has_n_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->n_val(), output);
  }

  // optional bool include_context = 13 [default = true];
  if (has_include_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->include_context(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtUpdateReq)
}

::google::protobuf::uint8* DtUpdateReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtUpdateReq)
  // required bytes bucket = 1;
  if (has_bucket()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->bucket(), target);
  }

  // optional bytes key = 2;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->key(), target);
  }

  // required bytes type = 3;
  if (has_type()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->type(), target);
  }

  // optional bytes context = 4;
  if (has_context()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->context(), target);
  }

  // required .DtOp op = 5;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->op(), target);
  }

  // optional uint32 w = 6;
  if (has_w()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->w(), target);
  }

  // optional uint32 dw = 7;
  if (has_dw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->dw(), target);
  }

  // optional uint32 pw = 8;
  if (has_pw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->pw(), target);
  }

  // optional bool return_body = 9 [default = false];
  if (has_return_body()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->return_body(), target);
  }

  // optional uint32 timeout = 10;
  if (has_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->timeout(), target);
  }

  // optional bool sloppy_quorum = 11;
  if (has_sloppy_quorum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->sloppy_quorum(), target);
  }

  // optional uint32 n_val = 12;
  if (has_n_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->n_val(), target);
  }

  // optional bool include_context = 13 [default = true];
  if (has_include_context()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->include_context(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtUpdateReq)
  return target;
}

int DtUpdateReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes bucket = 1;
    if (has_bucket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bucket());
    }

    // optional bytes key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // required bytes type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->type());
    }

    // optional bytes context = 4;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->context());
    }

    // required .DtOp op = 5;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->op());
    }

    // optional uint32 w = 6;
    if (has_w()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->w());
    }

    // optional uint32 dw = 7;
    if (has_dw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dw());
    }

    // optional uint32 pw = 8;
    if (has_pw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pw());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool return_body = 9 [default = false];
    if (has_return_body()) {
      total_size += 1 + 1;
    }

    // optional uint32 timeout = 10;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeout());
    }

    // optional bool sloppy_quorum = 11;
    if (has_sloppy_quorum()) {
      total_size += 1 + 1;
    }

    // optional uint32 n_val = 12;
    if (has_n_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_val());
    }

    // optional bool include_context = 13 [default = true];
    if (has_include_context()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtUpdateReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtUpdateReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtUpdateReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtUpdateReq::MergeFrom(const DtUpdateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bucket()) {
      set_bucket(from.bucket());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_op()) {
      mutable_op()->::DtOp::MergeFrom(from.op());
    }
    if (from.has_w()) {
      set_w(from.w());
    }
    if (from.has_dw()) {
      set_dw(from.dw());
    }
    if (from.has_pw()) {
      set_pw(from.pw());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_return_body()) {
      set_return_body(from.return_body());
    }
    if (from.has_timeout()) {
      set_timeout(from.timeout());
    }
    if (from.has_sloppy_quorum()) {
      set_sloppy_quorum(from.sloppy_quorum());
    }
    if (from.has_n_val()) {
      set_n_val(from.n_val());
    }
    if (from.has_include_context()) {
      set_include_context(from.include_context());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtUpdateReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtUpdateReq::CopyFrom(const DtUpdateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtUpdateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  if (has_op()) {
    if (!this->op().IsInitialized()) return false;
  }
  return true;
}

void DtUpdateReq::Swap(DtUpdateReq* other) {
  if (other != this) {
    std::swap(bucket_, other->bucket_);
    std::swap(key_, other->key_);
    std::swap(type_, other->type_);
    std::swap(context_, other->context_);
    std::swap(op_, other->op_);
    std::swap(w_, other->w_);
    std::swap(dw_, other->dw_);
    std::swap(pw_, other->pw_);
    std::swap(return_body_, other->return_body_);
    std::swap(timeout_, other->timeout_);
    std::swap(sloppy_quorum_, other->sloppy_quorum_);
    std::swap(n_val_, other->n_val_);
    std::swap(include_context_, other->include_context_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtUpdateReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtUpdateReq_descriptor_;
  metadata.reflection = DtUpdateReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DtUpdateResp::kKeyFieldNumber;
const int DtUpdateResp::kContextFieldNumber;
const int DtUpdateResp::kCounterValueFieldNumber;
const int DtUpdateResp::kSetValueFieldNumber;
const int DtUpdateResp::kMapValueFieldNumber;
#endif  // !_MSC_VER

DtUpdateResp::DtUpdateResp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DtUpdateResp)
}

void DtUpdateResp::InitAsDefaultInstance() {
}

DtUpdateResp::DtUpdateResp(const DtUpdateResp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DtUpdateResp)
}

void DtUpdateResp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  counter_value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DtUpdateResp::~DtUpdateResp() {
  // @@protoc_insertion_point(destructor:DtUpdateResp)
  SharedDtor();
}

void DtUpdateResp::SharedDtor() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (this != default_instance_) {
  }
}

void DtUpdateResp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DtUpdateResp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DtUpdateResp_descriptor_;
}

const DtUpdateResp& DtUpdateResp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_riak_5fdt_2eproto();
  return *default_instance_;
}

DtUpdateResp* DtUpdateResp::default_instance_ = NULL;

DtUpdateResp* DtUpdateResp::New() const {
  return new DtUpdateResp;
}

void DtUpdateResp::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
    if (has_context()) {
      if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        context_->clear();
      }
    }
    counter_value_ = GOOGLE_LONGLONG(0);
  }
  set_value_.Clear();
  map_value_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DtUpdateResp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DtUpdateResp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_context;
        break;
      }

      // optional bytes context = 2;
      case 2: {
        if (tag == 18) {
         parse_context:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_context()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_counter_value;
        break;
      }

      // optional sint64 counter_value = 3;
      case 3: {
        if (tag == 24) {
         parse_counter_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &counter_value_)));
          set_has_counter_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_set_value;
        break;
      }

      // repeated bytes set_value = 4;
      case 4: {
        if (tag == 34) {
         parse_set_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_set_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_set_value;
        if (input->ExpectTag(42)) goto parse_map_value;
        break;
      }

      // repeated .MapEntry map_value = 5;
      case 5: {
        if (tag == 42) {
         parse_map_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_map_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_map_value;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DtUpdateResp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DtUpdateResp)
  return false;
#undef DO_
}

void DtUpdateResp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DtUpdateResp)
  // optional bytes key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // optional bytes context = 2;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->context(), output);
  }

  // optional sint64 counter_value = 3;
  if (has_counter_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(3, this->counter_value(), output);
  }

  // repeated bytes set_value = 4;
  for (int i = 0; i < this->set_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->set_value(i), output);
  }

  // repeated .MapEntry map_value = 5;
  for (int i = 0; i < this->map_value_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->map_value(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DtUpdateResp)
}

::google::protobuf::uint8* DtUpdateResp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DtUpdateResp)
  // optional bytes key = 1;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->key(), target);
  }

  // optional bytes context = 2;
  if (has_context()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->context(), target);
  }

  // optional sint64 counter_value = 3;
  if (has_counter_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt64ToArray(3, this->counter_value(), target);
  }

  // repeated bytes set_value = 4;
  for (int i = 0; i < this->set_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(4, this->set_value(i), target);
  }

  // repeated .MapEntry map_value = 5;
  for (int i = 0; i < this->map_value_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->map_value(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DtUpdateResp)
  return target;
}

int DtUpdateResp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional bytes context = 2;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->context());
    }

    // optional sint64 counter_value = 3;
    if (has_counter_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->counter_value());
    }

  }
  // repeated bytes set_value = 4;
  total_size += 1 * this->set_value_size();
  for (int i = 0; i < this->set_value_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->set_value(i));
  }

  // repeated .MapEntry map_value = 5;
  total_size += 1 * this->map_value_size();
  for (int i = 0; i < this->map_value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->map_value(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DtUpdateResp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DtUpdateResp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DtUpdateResp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DtUpdateResp::MergeFrom(const DtUpdateResp& from) {
  GOOGLE_CHECK_NE(&from, this);
  set_value_.MergeFrom(from.set_value_);
  map_value_.MergeFrom(from.map_value_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_counter_value()) {
      set_counter_value(from.counter_value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DtUpdateResp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DtUpdateResp::CopyFrom(const DtUpdateResp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DtUpdateResp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->map_value())) return false;
  return true;
}

void DtUpdateResp::Swap(DtUpdateResp* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(context_, other->context_);
    std::swap(counter_value_, other->counter_value_);
    set_value_.Swap(&other->set_value_);
    map_value_.Swap(&other->map_value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DtUpdateResp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DtUpdateResp_descriptor_;
  metadata.reflection = DtUpdateResp_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
