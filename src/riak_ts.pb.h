// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak_ts.proto

#ifndef PROTOBUF_riak_5fts_2eproto__INCLUDED
#define PROTOBUF_riak_5fts_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "riak.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_5fts_2eproto();
void protobuf_AssignDesc_riak_5fts_2eproto();
void protobuf_ShutdownFile_riak_5fts_2eproto();

class TsQueryReq;
class TsQueryResp;
class TsGetReq;
class TsGetResp;
class TsPutReq;
class TsTtbPutReq;
class TsPutResp;
class TsDelReq;
class TsDelResp;
class TsInterpolation;
class TsColumnDescription;
class TsRow;
class TsCell;
class TsListKeysReq;
class TsListKeysResp;
class TsCoverageReq;
class TsCoverageResp;
class TsCoverageEntry;
class TsRange;

enum TsColumnType {
  VARCHAR = 0,
  SINT64 = 1,
  DOUBLE = 2,
  TIMESTAMP = 3,
  BOOLEAN = 4
};
bool TsColumnType_IsValid(int value);
const TsColumnType TsColumnType_MIN = VARCHAR;
const TsColumnType TsColumnType_MAX = BOOLEAN;
const int TsColumnType_ARRAYSIZE = TsColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TsColumnType_descriptor();
inline const ::std::string& TsColumnType_Name(TsColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TsColumnType_descriptor(), value);
}
inline bool TsColumnType_Parse(
    const ::std::string& name, TsColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TsColumnType>(
    TsColumnType_descriptor(), name, value);
}
// ===================================================================

class TsQueryReq : public ::google::protobuf::Message {
 public:
  TsQueryReq();
  virtual ~TsQueryReq();

  TsQueryReq(const TsQueryReq& from);

  inline TsQueryReq& operator=(const TsQueryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsQueryReq& default_instance();

  void Swap(TsQueryReq* other);

  // implements Message ----------------------------------------------

  TsQueryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsQueryReq& from);
  void MergeFrom(const TsQueryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TsInterpolation query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::TsInterpolation& query() const;
  inline ::TsInterpolation* mutable_query();
  inline ::TsInterpolation* release_query();
  inline void set_allocated_query(::TsInterpolation* query);

  // optional bool stream = 2 [default = false];
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bytes cover_context = 3;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 3;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:TsQueryReq)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TsInterpolation* query_;
  ::std::string* cover_context_;
  bool stream_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsQueryReq* default_instance_;
};
// -------------------------------------------------------------------

class TsQueryResp : public ::google::protobuf::Message {
 public:
  TsQueryResp();
  virtual ~TsQueryResp();

  TsQueryResp(const TsQueryResp& from);

  inline TsQueryResp& operator=(const TsQueryResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsQueryResp& default_instance();

  void Swap(TsQueryResp* other);

  // implements Message ----------------------------------------------

  TsQueryResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsQueryResp& from);
  void MergeFrom(const TsQueryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsColumnDescription columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // optional bool done = 3 [default = true];
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:TsQueryResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsQueryResp* default_instance_;
};
// -------------------------------------------------------------------

class TsGetReq : public ::google::protobuf::Message {
 public:
  TsGetReq();
  virtual ~TsGetReq();

  TsGetReq(const TsGetReq& from);

  inline TsGetReq& operator=(const TsGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsGetReq& default_instance();

  void Swap(TsGetReq* other);

  // implements Message ----------------------------------------------

  TsGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsGetReq& from);
  void MergeFrom(const TsGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsCell key = 2;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::TsCell& key(int index) const;
  inline ::TsCell* mutable_key(int index);
  inline ::TsCell* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_key();

  // optional uint32 timeout = 3;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsGetReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > key_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsGetReq* default_instance_;
};
// -------------------------------------------------------------------

class TsGetResp : public ::google::protobuf::Message {
 public:
  TsGetResp();
  virtual ~TsGetResp();

  TsGetResp(const TsGetResp& from);

  inline TsGetResp& operator=(const TsGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsGetResp& default_instance();

  void Swap(TsGetResp* other);

  // implements Message ----------------------------------------------

  TsGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsGetResp& from);
  void MergeFrom(const TsGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsColumnDescription columns = 1;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 1;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 2;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsGetResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsGetResp* default_instance_;
};
// -------------------------------------------------------------------

class TsPutReq : public ::google::protobuf::Message {
 public:
  TsPutReq();
  virtual ~TsPutReq();

  TsPutReq(const TsPutReq& from);

  inline TsPutReq& operator=(const TsPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsPutReq& default_instance();

  void Swap(TsPutReq* other);

  // implements Message ----------------------------------------------

  TsPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsPutReq& from);
  void MergeFrom(const TsPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsColumnDescription columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 3;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsPutReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsPutReq* default_instance_;
};
// -------------------------------------------------------------------

class TsTtbPutReq : public ::google::protobuf::Message {
 public:
  TsTtbPutReq();
  virtual ~TsTtbPutReq();

  TsTtbPutReq(const TsTtbPutReq& from);

  inline TsTtbPutReq& operator=(const TsTtbPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsTtbPutReq& default_instance();

  void Swap(TsTtbPutReq* other);

  // implements Message ----------------------------------------------

  TsTtbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsTtbPutReq& from);
  void MergeFrom(const TsTtbPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsColumnDescription columns = 2;
  inline int columns_size() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline const ::TsColumnDescription& columns(int index) const;
  inline ::TsColumnDescription* mutable_columns(int index);
  inline ::TsColumnDescription* add_columns();
  inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
      columns() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
      mutable_columns();

  // repeated .TsRow rows = 3;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 3;
  inline const ::TsRow& rows(int index) const;
  inline ::TsRow* mutable_rows(int index);
  inline ::TsRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:TsTtbPutReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsColumnDescription > columns_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > rows_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsTtbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class TsPutResp : public ::google::protobuf::Message {
 public:
  TsPutResp();
  virtual ~TsPutResp();

  TsPutResp(const TsPutResp& from);

  inline TsPutResp& operator=(const TsPutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsPutResp& default_instance();

  void Swap(TsPutResp* other);

  // implements Message ----------------------------------------------

  TsPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsPutResp& from);
  void MergeFrom(const TsPutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TsPutResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsPutResp* default_instance_;
};
// -------------------------------------------------------------------

class TsDelReq : public ::google::protobuf::Message {
 public:
  TsDelReq();
  virtual ~TsDelReq();

  TsDelReq(const TsDelReq& from);

  inline TsDelReq& operator=(const TsDelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsDelReq& default_instance();

  void Swap(TsDelReq* other);

  // implements Message ----------------------------------------------

  TsDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsDelReq& from);
  void MergeFrom(const TsDelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // repeated .TsCell key = 2;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::TsCell& key(int index) const;
  inline ::TsCell* mutable_key(int index);
  inline ::TsCell* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_key();

  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional uint32 timeout = 4;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsDelReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsDelReq* default_instance_;
};
// -------------------------------------------------------------------

class TsDelResp : public ::google::protobuf::Message {
 public:
  TsDelResp();
  virtual ~TsDelResp();

  TsDelResp(const TsDelResp& from);

  inline TsDelResp& operator=(const TsDelResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsDelResp& default_instance();

  void Swap(TsDelResp* other);

  // implements Message ----------------------------------------------

  TsDelResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsDelResp& from);
  void MergeFrom(const TsDelResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TsDelResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsDelResp* default_instance_;
};
// -------------------------------------------------------------------

class TsInterpolation : public ::google::protobuf::Message {
 public:
  TsInterpolation();
  virtual ~TsInterpolation();

  TsInterpolation(const TsInterpolation& from);

  inline TsInterpolation& operator=(const TsInterpolation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsInterpolation& default_instance();

  void Swap(TsInterpolation* other);

  // implements Message ----------------------------------------------

  TsInterpolation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsInterpolation& from);
  void MergeFrom(const TsInterpolation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::std::string& base() const;
  inline void set_base(const ::std::string& value);
  inline void set_base(const char* value);
  inline void set_base(const void* value, size_t size);
  inline ::std::string* mutable_base();
  inline ::std::string* release_base();
  inline void set_allocated_base(::std::string* base);

  // repeated .RpbPair interpolations = 2;
  inline int interpolations_size() const;
  inline void clear_interpolations();
  static const int kInterpolationsFieldNumber = 2;
  inline const ::RpbPair& interpolations(int index) const;
  inline ::RpbPair* mutable_interpolations(int index);
  inline ::RpbPair* add_interpolations();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      interpolations() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_interpolations();

  // @@protoc_insertion_point(class_scope:TsInterpolation)
 private:
  inline void set_has_base();
  inline void clear_has_base();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* base_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > interpolations_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsInterpolation* default_instance_;
};
// -------------------------------------------------------------------

class TsColumnDescription : public ::google::protobuf::Message {
 public:
  TsColumnDescription();
  virtual ~TsColumnDescription();

  TsColumnDescription(const TsColumnDescription& from);

  inline TsColumnDescription& operator=(const TsColumnDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsColumnDescription& default_instance();

  void Swap(TsColumnDescription* other);

  // implements Message ----------------------------------------------

  TsColumnDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsColumnDescription& from);
  void MergeFrom(const TsColumnDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .TsColumnType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::TsColumnType type() const;
  inline void set_type(::TsColumnType value);

  // @@protoc_insertion_point(class_scope:TsColumnDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsColumnDescription* default_instance_;
};
// -------------------------------------------------------------------

class TsRow : public ::google::protobuf::Message {
 public:
  TsRow();
  virtual ~TsRow();

  TsRow(const TsRow& from);

  inline TsRow& operator=(const TsRow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsRow& default_instance();

  void Swap(TsRow* other);

  // implements Message ----------------------------------------------

  TsRow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsRow& from);
  void MergeFrom(const TsRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsCell cells = 1;
  inline int cells_size() const;
  inline void clear_cells();
  static const int kCellsFieldNumber = 1;
  inline const ::TsCell& cells(int index) const;
  inline ::TsCell* mutable_cells(int index);
  inline ::TsCell* add_cells();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
      cells() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
      mutable_cells();

  // @@protoc_insertion_point(class_scope:TsRow)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsCell > cells_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsRow* default_instance_;
};
// -------------------------------------------------------------------

class TsCell : public ::google::protobuf::Message {
 public:
  TsCell();
  virtual ~TsCell();

  TsCell(const TsCell& from);

  inline TsCell& operator=(const TsCell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCell& default_instance();

  void Swap(TsCell* other);

  // implements Message ----------------------------------------------

  TsCell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCell& from);
  void MergeFrom(const TsCell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes varchar_value = 1;
  inline bool has_varchar_value() const;
  inline void clear_varchar_value();
  static const int kVarcharValueFieldNumber = 1;
  inline const ::std::string& varchar_value() const;
  inline void set_varchar_value(const ::std::string& value);
  inline void set_varchar_value(const char* value);
  inline void set_varchar_value(const void* value, size_t size);
  inline ::std::string* mutable_varchar_value();
  inline ::std::string* release_varchar_value();
  inline void set_allocated_varchar_value(::std::string* varchar_value);

  // optional sint64 sint64_value = 2;
  inline bool has_sint64_value() const;
  inline void clear_sint64_value();
  static const int kSint64ValueFieldNumber = 2;
  inline ::google::protobuf::int64 sint64_value() const;
  inline void set_sint64_value(::google::protobuf::int64 value);

  // optional sint64 timestamp_value = 3;
  inline bool has_timestamp_value() const;
  inline void clear_timestamp_value();
  static const int kTimestampValueFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp_value() const;
  inline void set_timestamp_value(::google::protobuf::int64 value);

  // optional bool boolean_value = 4;
  inline bool has_boolean_value() const;
  inline void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 4;
  inline bool boolean_value() const;
  inline void set_boolean_value(bool value);

  // optional double double_value = 5;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 5;
  inline double double_value() const;
  inline void set_double_value(double value);

  // @@protoc_insertion_point(class_scope:TsCell)
 private:
  inline void set_has_varchar_value();
  inline void clear_has_varchar_value();
  inline void set_has_sint64_value();
  inline void clear_has_sint64_value();
  inline void set_has_timestamp_value();
  inline void clear_has_timestamp_value();
  inline void set_has_boolean_value();
  inline void clear_has_boolean_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* varchar_value_;
  ::google::protobuf::int64 sint64_value_;
  ::google::protobuf::int64 timestamp_value_;
  double double_value_;
  bool boolean_value_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsCell* default_instance_;
};
// -------------------------------------------------------------------

class TsListKeysReq : public ::google::protobuf::Message {
 public:
  TsListKeysReq();
  virtual ~TsListKeysReq();

  TsListKeysReq(const TsListKeysReq& from);

  inline TsListKeysReq& operator=(const TsListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsListKeysReq& default_instance();

  void Swap(TsListKeysReq* other);

  // implements Message ----------------------------------------------

  TsListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsListKeysReq& from);
  void MergeFrom(const TsListKeysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TsListKeysReq)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_timeout();
  inline void clear_has_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* table_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class TsListKeysResp : public ::google::protobuf::Message {
 public:
  TsListKeysResp();
  virtual ~TsListKeysResp();

  TsListKeysResp(const TsListKeysResp& from);

  inline TsListKeysResp& operator=(const TsListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsListKeysResp& default_instance();

  void Swap(TsListKeysResp* other);

  // implements Message ----------------------------------------------

  TsListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsListKeysResp& from);
  void MergeFrom(const TsListKeysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsRow keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::TsRow& keys(int index) const;
  inline ::TsRow* mutable_keys(int index);
  inline ::TsRow* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
      mutable_keys();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:TsListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsRow > keys_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageReq : public ::google::protobuf::Message {
 public:
  TsCoverageReq();
  virtual ~TsCoverageReq();

  TsCoverageReq(const TsCoverageReq& from);

  inline TsCoverageReq& operator=(const TsCoverageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageReq& default_instance();

  void Swap(TsCoverageReq* other);

  // implements Message ----------------------------------------------

  TsCoverageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageReq& from);
  void MergeFrom(const TsCoverageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TsInterpolation query = 1;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 1;
  inline const ::TsInterpolation& query() const;
  inline ::TsInterpolation* mutable_query();
  inline ::TsInterpolation* release_query();
  inline void set_allocated_query(::TsInterpolation* query);

  // required bytes table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const void* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  inline void set_allocated_table(::std::string* table);

  // optional bytes replace_cover = 3;
  inline bool has_replace_cover() const;
  inline void clear_replace_cover();
  static const int kReplaceCoverFieldNumber = 3;
  inline const ::std::string& replace_cover() const;
  inline void set_replace_cover(const ::std::string& value);
  inline void set_replace_cover(const char* value);
  inline void set_replace_cover(const void* value, size_t size);
  inline ::std::string* mutable_replace_cover();
  inline ::std::string* release_replace_cover();
  inline void set_allocated_replace_cover(::std::string* replace_cover);

  // repeated bytes unavailable_cover = 4;
  inline int unavailable_cover_size() const;
  inline void clear_unavailable_cover();
  static const int kUnavailableCoverFieldNumber = 4;
  inline const ::std::string& unavailable_cover(int index) const;
  inline ::std::string* mutable_unavailable_cover(int index);
  inline void set_unavailable_cover(int index, const ::std::string& value);
  inline void set_unavailable_cover(int index, const char* value);
  inline void set_unavailable_cover(int index, const void* value, size_t size);
  inline ::std::string* add_unavailable_cover();
  inline void add_unavailable_cover(const ::std::string& value);
  inline void add_unavailable_cover(const char* value);
  inline void add_unavailable_cover(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unavailable_cover() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unavailable_cover();

  // @@protoc_insertion_point(class_scope:TsCoverageReq)
 private:
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_replace_cover();
  inline void clear_has_replace_cover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TsInterpolation* query_;
  ::std::string* table_;
  ::std::string* replace_cover_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unavailable_cover_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageReq* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageResp : public ::google::protobuf::Message {
 public:
  TsCoverageResp();
  virtual ~TsCoverageResp();

  TsCoverageResp(const TsCoverageResp& from);

  inline TsCoverageResp& operator=(const TsCoverageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageResp& default_instance();

  void Swap(TsCoverageResp* other);

  // implements Message ----------------------------------------------

  TsCoverageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageResp& from);
  void MergeFrom(const TsCoverageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TsCoverageEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TsCoverageEntry& entries(int index) const;
  inline ::TsCoverageEntry* mutable_entries(int index);
  inline ::TsCoverageEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TsCoverageResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry > entries_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageResp* default_instance_;
};
// -------------------------------------------------------------------

class TsCoverageEntry : public ::google::protobuf::Message {
 public:
  TsCoverageEntry();
  virtual ~TsCoverageEntry();

  TsCoverageEntry(const TsCoverageEntry& from);

  inline TsCoverageEntry& operator=(const TsCoverageEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsCoverageEntry& default_instance();

  void Swap(TsCoverageEntry* other);

  // implements Message ----------------------------------------------

  TsCoverageEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsCoverageEntry& from);
  void MergeFrom(const TsCoverageEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required bytes cover_context = 3;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 3;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // optional .TsRange range = 4;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 4;
  inline const ::TsRange& range() const;
  inline ::TsRange* mutable_range();
  inline ::TsRange* release_range();
  inline void set_allocated_range(::TsRange* range);

  // @@protoc_insertion_point(class_scope:TsCoverageEntry)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* cover_context_;
  ::TsRange* range_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsCoverageEntry* default_instance_;
};
// -------------------------------------------------------------------

class TsRange : public ::google::protobuf::Message {
 public:
  TsRange();
  virtual ~TsRange();

  TsRange(const TsRange& from);

  inline TsRange& operator=(const TsRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TsRange& default_instance();

  void Swap(TsRange* other);

  // implements Message ----------------------------------------------

  TsRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TsRange& from);
  void MergeFrom(const TsRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes field_name = 1;
  inline bool has_field_name() const;
  inline void clear_field_name();
  static const int kFieldNameFieldNumber = 1;
  inline const ::std::string& field_name() const;
  inline void set_field_name(const ::std::string& value);
  inline void set_field_name(const char* value);
  inline void set_field_name(const void* value, size_t size);
  inline ::std::string* mutable_field_name();
  inline ::std::string* release_field_name();
  inline void set_allocated_field_name(::std::string* field_name);

  // required sint64 lower_bound = 2;
  inline bool has_lower_bound() const;
  inline void clear_lower_bound();
  static const int kLowerBoundFieldNumber = 2;
  inline ::google::protobuf::int64 lower_bound() const;
  inline void set_lower_bound(::google::protobuf::int64 value);

  // required bool lower_bound_inclusive = 3;
  inline bool has_lower_bound_inclusive() const;
  inline void clear_lower_bound_inclusive();
  static const int kLowerBoundInclusiveFieldNumber = 3;
  inline bool lower_bound_inclusive() const;
  inline void set_lower_bound_inclusive(bool value);

  // required sint64 upper_bound = 4;
  inline bool has_upper_bound() const;
  inline void clear_upper_bound();
  static const int kUpperBoundFieldNumber = 4;
  inline ::google::protobuf::int64 upper_bound() const;
  inline void set_upper_bound(::google::protobuf::int64 value);

  // required bool upper_bound_inclusive = 5;
  inline bool has_upper_bound_inclusive() const;
  inline void clear_upper_bound_inclusive();
  static const int kUpperBoundInclusiveFieldNumber = 5;
  inline bool upper_bound_inclusive() const;
  inline void set_upper_bound_inclusive(bool value);

  // required bytes desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:TsRange)
 private:
  inline void set_has_field_name();
  inline void clear_has_field_name();
  inline void set_has_lower_bound();
  inline void clear_has_lower_bound();
  inline void set_has_lower_bound_inclusive();
  inline void clear_has_lower_bound_inclusive();
  inline void set_has_upper_bound();
  inline void clear_has_upper_bound();
  inline void set_has_upper_bound_inclusive();
  inline void clear_has_upper_bound_inclusive();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* field_name_;
  ::google::protobuf::int64 lower_bound_;
  ::google::protobuf::int64 upper_bound_;
  ::std::string* desc_;
  bool lower_bound_inclusive_;
  bool upper_bound_inclusive_;
  friend void  protobuf_AddDesc_riak_5fts_2eproto();
  friend void protobuf_AssignDesc_riak_5fts_2eproto();
  friend void protobuf_ShutdownFile_riak_5fts_2eproto();

  void InitAsDefaultInstance();
  static TsRange* default_instance_;
};
// ===================================================================


// ===================================================================

// TsQueryReq

// optional .TsInterpolation query = 1;
inline bool TsQueryReq::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsQueryReq::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsQueryReq::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsQueryReq::clear_query() {
  if (query_ != NULL) query_->::TsInterpolation::Clear();
  clear_has_query();
}
inline const ::TsInterpolation& TsQueryReq::query() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.query)
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::TsInterpolation* TsQueryReq::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::TsInterpolation;
  // @@protoc_insertion_point(field_mutable:TsQueryReq.query)
  return query_;
}
inline ::TsInterpolation* TsQueryReq::release_query() {
  clear_has_query();
  ::TsInterpolation* temp = query_;
  query_ = NULL;
  return temp;
}
inline void TsQueryReq::set_allocated_query(::TsInterpolation* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:TsQueryReq.query)
}

// optional bool stream = 2 [default = false];
inline bool TsQueryReq::has_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsQueryReq::set_has_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsQueryReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsQueryReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool TsQueryReq::stream() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.stream)
  return stream_;
}
inline void TsQueryReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:TsQueryReq.stream)
}

// optional bytes cover_context = 3;
inline bool TsQueryReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsQueryReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsQueryReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsQueryReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& TsQueryReq::cover_context() const {
  // @@protoc_insertion_point(field_get:TsQueryReq.cover_context)
  return *cover_context_;
}
inline void TsQueryReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:TsQueryReq.cover_context)
}
inline void TsQueryReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsQueryReq.cover_context)
}
inline void TsQueryReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsQueryReq.cover_context)
}
inline ::std::string* TsQueryReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsQueryReq.cover_context)
  return cover_context_;
}
inline ::std::string* TsQueryReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsQueryReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsQueryReq.cover_context)
}

// -------------------------------------------------------------------

// TsQueryResp

// repeated .TsColumnDescription columns = 1;
inline int TsQueryResp::columns_size() const {
  return columns_.size();
}
inline void TsQueryResp::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsQueryResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsQueryResp.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsQueryResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsQueryResp.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsQueryResp::add_columns() {
  // @@protoc_insertion_point(field_add:TsQueryResp.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsQueryResp::columns() const {
  // @@protoc_insertion_point(field_list:TsQueryResp.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsQueryResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsQueryResp.columns)
  return &columns_;
}

// repeated .TsRow rows = 2;
inline int TsQueryResp::rows_size() const {
  return rows_.size();
}
inline void TsQueryResp::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsQueryResp::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsQueryResp.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsQueryResp::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsQueryResp.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsQueryResp::add_rows() {
  // @@protoc_insertion_point(field_add:TsQueryResp.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsQueryResp::rows() const {
  // @@protoc_insertion_point(field_list:TsQueryResp.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsQueryResp::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsQueryResp.rows)
  return &rows_;
}

// optional bool done = 3 [default = true];
inline bool TsQueryResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsQueryResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsQueryResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsQueryResp::clear_done() {
  done_ = true;
  clear_has_done();
}
inline bool TsQueryResp::done() const {
  // @@protoc_insertion_point(field_get:TsQueryResp.done)
  return done_;
}
inline void TsQueryResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:TsQueryResp.done)
}

// -------------------------------------------------------------------

// TsGetReq

// required bytes table = 1;
inline bool TsGetReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsGetReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsGetReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsGetReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsGetReq::table() const {
  // @@protoc_insertion_point(field_get:TsGetReq.table)
  return *table_;
}
inline void TsGetReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsGetReq.table)
}
inline void TsGetReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsGetReq.table)
}
inline void TsGetReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsGetReq.table)
}
inline ::std::string* TsGetReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsGetReq.table)
  return table_;
}
inline ::std::string* TsGetReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsGetReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsGetReq.table)
}

// repeated .TsCell key = 2;
inline int TsGetReq::key_size() const {
  return key_.size();
}
inline void TsGetReq::clear_key() {
  key_.Clear();
}
inline const ::TsCell& TsGetReq::key(int index) const {
  // @@protoc_insertion_point(field_get:TsGetReq.key)
  return key_.Get(index);
}
inline ::TsCell* TsGetReq::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetReq.key)
  return key_.Mutable(index);
}
inline ::TsCell* TsGetReq::add_key() {
  // @@protoc_insertion_point(field_add:TsGetReq.key)
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsGetReq::key() const {
  // @@protoc_insertion_point(field_list:TsGetReq.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsGetReq::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:TsGetReq.key)
  return &key_;
}

// optional uint32 timeout = 3;
inline bool TsGetReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsGetReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsGetReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsGetReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsGetReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsGetReq.timeout)
  return timeout_;
}
inline void TsGetReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsGetReq.timeout)
}

// -------------------------------------------------------------------

// TsGetResp

// repeated .TsColumnDescription columns = 1;
inline int TsGetResp::columns_size() const {
  return columns_.size();
}
inline void TsGetResp::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsGetResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsGetResp.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsGetResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetResp.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsGetResp::add_columns() {
  // @@protoc_insertion_point(field_add:TsGetResp.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsGetResp::columns() const {
  // @@protoc_insertion_point(field_list:TsGetResp.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsGetResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsGetResp.columns)
  return &columns_;
}

// repeated .TsRow rows = 2;
inline int TsGetResp::rows_size() const {
  return rows_.size();
}
inline void TsGetResp::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsGetResp::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsGetResp.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsGetResp::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsGetResp.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsGetResp::add_rows() {
  // @@protoc_insertion_point(field_add:TsGetResp.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsGetResp::rows() const {
  // @@protoc_insertion_point(field_list:TsGetResp.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsGetResp::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsGetResp.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsPutReq

// required bytes table = 1;
inline bool TsPutReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsPutReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsPutReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsPutReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsPutReq::table() const {
  // @@protoc_insertion_point(field_get:TsPutReq.table)
  return *table_;
}
inline void TsPutReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsPutReq.table)
}
inline void TsPutReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsPutReq.table)
}
inline void TsPutReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsPutReq.table)
}
inline ::std::string* TsPutReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsPutReq.table)
  return table_;
}
inline ::std::string* TsPutReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsPutReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsPutReq.table)
}

// repeated .TsColumnDescription columns = 2;
inline int TsPutReq::columns_size() const {
  return columns_.size();
}
inline void TsPutReq::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsPutReq::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsPutReq.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsPutReq::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsPutReq.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsPutReq::add_columns() {
  // @@protoc_insertion_point(field_add:TsPutReq.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsPutReq::columns() const {
  // @@protoc_insertion_point(field_list:TsPutReq.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsPutReq::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsPutReq.columns)
  return &columns_;
}

// repeated .TsRow rows = 3;
inline int TsPutReq::rows_size() const {
  return rows_.size();
}
inline void TsPutReq::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsPutReq::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsPutReq.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsPutReq::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsPutReq.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsPutReq::add_rows() {
  // @@protoc_insertion_point(field_add:TsPutReq.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsPutReq::rows() const {
  // @@protoc_insertion_point(field_list:TsPutReq.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsPutReq::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsPutReq.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsTtbPutReq

// required bytes table = 1;
inline bool TsTtbPutReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsTtbPutReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsTtbPutReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsTtbPutReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsTtbPutReq::table() const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.table)
  return *table_;
}
inline void TsTtbPutReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsTtbPutReq.table)
}
inline void TsTtbPutReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsTtbPutReq.table)
}
inline void TsTtbPutReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsTtbPutReq.table)
}
inline ::std::string* TsTtbPutReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.table)
  return table_;
}
inline ::std::string* TsTtbPutReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsTtbPutReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsTtbPutReq.table)
}

// repeated .TsColumnDescription columns = 2;
inline int TsTtbPutReq::columns_size() const {
  return columns_.size();
}
inline void TsTtbPutReq::clear_columns() {
  columns_.Clear();
}
inline const ::TsColumnDescription& TsTtbPutReq::columns(int index) const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.columns)
  return columns_.Get(index);
}
inline ::TsColumnDescription* TsTtbPutReq::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.columns)
  return columns_.Mutable(index);
}
inline ::TsColumnDescription* TsTtbPutReq::add_columns() {
  // @@protoc_insertion_point(field_add:TsTtbPutReq.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >&
TsTtbPutReq::columns() const {
  // @@protoc_insertion_point(field_list:TsTtbPutReq.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsColumnDescription >*
TsTtbPutReq::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:TsTtbPutReq.columns)
  return &columns_;
}

// repeated .TsRow rows = 3;
inline int TsTtbPutReq::rows_size() const {
  return rows_.size();
}
inline void TsTtbPutReq::clear_rows() {
  rows_.Clear();
}
inline const ::TsRow& TsTtbPutReq::rows(int index) const {
  // @@protoc_insertion_point(field_get:TsTtbPutReq.rows)
  return rows_.Get(index);
}
inline ::TsRow* TsTtbPutReq::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:TsTtbPutReq.rows)
  return rows_.Mutable(index);
}
inline ::TsRow* TsTtbPutReq::add_rows() {
  // @@protoc_insertion_point(field_add:TsTtbPutReq.rows)
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsTtbPutReq::rows() const {
  // @@protoc_insertion_point(field_list:TsTtbPutReq.rows)
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsTtbPutReq::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:TsTtbPutReq.rows)
  return &rows_;
}

// -------------------------------------------------------------------

// TsPutResp

// -------------------------------------------------------------------

// TsDelReq

// required bytes table = 1;
inline bool TsDelReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsDelReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsDelReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsDelReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsDelReq::table() const {
  // @@protoc_insertion_point(field_get:TsDelReq.table)
  return *table_;
}
inline void TsDelReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsDelReq.table)
}
inline void TsDelReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsDelReq.table)
}
inline void TsDelReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsDelReq.table)
}
inline ::std::string* TsDelReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsDelReq.table)
  return table_;
}
inline ::std::string* TsDelReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsDelReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsDelReq.table)
}

// repeated .TsCell key = 2;
inline int TsDelReq::key_size() const {
  return key_.size();
}
inline void TsDelReq::clear_key() {
  key_.Clear();
}
inline const ::TsCell& TsDelReq::key(int index) const {
  // @@protoc_insertion_point(field_get:TsDelReq.key)
  return key_.Get(index);
}
inline ::TsCell* TsDelReq::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:TsDelReq.key)
  return key_.Mutable(index);
}
inline ::TsCell* TsDelReq::add_key() {
  // @@protoc_insertion_point(field_add:TsDelReq.key)
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsDelReq::key() const {
  // @@protoc_insertion_point(field_list:TsDelReq.key)
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsDelReq::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:TsDelReq.key)
  return &key_;
}

// optional bytes vclock = 3;
inline bool TsDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& TsDelReq::vclock() const {
  // @@protoc_insertion_point(field_get:TsDelReq.vclock)
  return *vclock_;
}
inline void TsDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:TsDelReq.vclock)
}
inline void TsDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsDelReq.vclock)
}
inline void TsDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsDelReq.vclock)
}
inline ::std::string* TsDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsDelReq.vclock)
  return vclock_;
}
inline ::std::string* TsDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsDelReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsDelReq.vclock)
}

// optional uint32 timeout = 4;
inline bool TsDelReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsDelReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsDelReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsDelReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsDelReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsDelReq.timeout)
  return timeout_;
}
inline void TsDelReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsDelReq.timeout)
}

// -------------------------------------------------------------------

// TsDelResp

// -------------------------------------------------------------------

// TsInterpolation

// required bytes base = 1;
inline bool TsInterpolation::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsInterpolation::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsInterpolation::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsInterpolation::clear_base() {
  if (base_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_->clear();
  }
  clear_has_base();
}
inline const ::std::string& TsInterpolation::base() const {
  // @@protoc_insertion_point(field_get:TsInterpolation.base)
  return *base_;
}
inline void TsInterpolation::set_base(const ::std::string& value) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(value);
  // @@protoc_insertion_point(field_set:TsInterpolation.base)
}
inline void TsInterpolation::set_base(const char* value) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsInterpolation.base)
}
inline void TsInterpolation::set_base(const void* value, size_t size) {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  base_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsInterpolation.base)
}
inline ::std::string* TsInterpolation::mutable_base() {
  set_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    base_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsInterpolation.base)
  return base_;
}
inline ::std::string* TsInterpolation::release_base() {
  clear_has_base();
  if (base_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = base_;
    base_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsInterpolation::set_allocated_base(::std::string* base) {
  if (base_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete base_;
  }
  if (base) {
    set_has_base();
    base_ = base;
  } else {
    clear_has_base();
    base_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsInterpolation.base)
}

// repeated .RpbPair interpolations = 2;
inline int TsInterpolation::interpolations_size() const {
  return interpolations_.size();
}
inline void TsInterpolation::clear_interpolations() {
  interpolations_.Clear();
}
inline const ::RpbPair& TsInterpolation::interpolations(int index) const {
  // @@protoc_insertion_point(field_get:TsInterpolation.interpolations)
  return interpolations_.Get(index);
}
inline ::RpbPair* TsInterpolation::mutable_interpolations(int index) {
  // @@protoc_insertion_point(field_mutable:TsInterpolation.interpolations)
  return interpolations_.Mutable(index);
}
inline ::RpbPair* TsInterpolation::add_interpolations() {
  // @@protoc_insertion_point(field_add:TsInterpolation.interpolations)
  return interpolations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
TsInterpolation::interpolations() const {
  // @@protoc_insertion_point(field_list:TsInterpolation.interpolations)
  return interpolations_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
TsInterpolation::mutable_interpolations() {
  // @@protoc_insertion_point(field_mutable_list:TsInterpolation.interpolations)
  return &interpolations_;
}

// -------------------------------------------------------------------

// TsColumnDescription

// required bytes name = 1;
inline bool TsColumnDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsColumnDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsColumnDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsColumnDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TsColumnDescription::name() const {
  // @@protoc_insertion_point(field_get:TsColumnDescription.name)
  return *name_;
}
inline void TsColumnDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:TsColumnDescription.name)
}
inline void TsColumnDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsColumnDescription.name)
}
inline void TsColumnDescription::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsColumnDescription.name)
}
inline ::std::string* TsColumnDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsColumnDescription.name)
  return name_;
}
inline ::std::string* TsColumnDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsColumnDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsColumnDescription.name)
}

// required .TsColumnType type = 2;
inline bool TsColumnDescription::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsColumnDescription::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsColumnDescription::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsColumnDescription::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TsColumnType TsColumnDescription::type() const {
  // @@protoc_insertion_point(field_get:TsColumnDescription.type)
  return static_cast< ::TsColumnType >(type_);
}
inline void TsColumnDescription::set_type(::TsColumnType value) {
  assert(::TsColumnType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TsColumnDescription.type)
}

// -------------------------------------------------------------------

// TsRow

// repeated .TsCell cells = 1;
inline int TsRow::cells_size() const {
  return cells_.size();
}
inline void TsRow::clear_cells() {
  cells_.Clear();
}
inline const ::TsCell& TsRow::cells(int index) const {
  // @@protoc_insertion_point(field_get:TsRow.cells)
  return cells_.Get(index);
}
inline ::TsCell* TsRow::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:TsRow.cells)
  return cells_.Mutable(index);
}
inline ::TsCell* TsRow::add_cells() {
  // @@protoc_insertion_point(field_add:TsRow.cells)
  return cells_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCell >&
TsRow::cells() const {
  // @@protoc_insertion_point(field_list:TsRow.cells)
  return cells_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCell >*
TsRow::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:TsRow.cells)
  return &cells_;
}

// -------------------------------------------------------------------

// TsCell

// optional bytes varchar_value = 1;
inline bool TsCell::has_varchar_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCell::set_has_varchar_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCell::clear_has_varchar_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCell::clear_varchar_value() {
  if (varchar_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_->clear();
  }
  clear_has_varchar_value();
}
inline const ::std::string& TsCell::varchar_value() const {
  // @@protoc_insertion_point(field_get:TsCell.varchar_value)
  return *varchar_value_;
}
inline void TsCell::set_varchar_value(const ::std::string& value) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(value);
  // @@protoc_insertion_point(field_set:TsCell.varchar_value)
}
inline void TsCell::set_varchar_value(const char* value) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCell.varchar_value)
}
inline void TsCell::set_varchar_value(const void* value, size_t size) {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  varchar_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCell.varchar_value)
}
inline ::std::string* TsCell::mutable_varchar_value() {
  set_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    varchar_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCell.varchar_value)
  return varchar_value_;
}
inline ::std::string* TsCell::release_varchar_value() {
  clear_has_varchar_value();
  if (varchar_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = varchar_value_;
    varchar_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCell::set_allocated_varchar_value(::std::string* varchar_value) {
  if (varchar_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete varchar_value_;
  }
  if (varchar_value) {
    set_has_varchar_value();
    varchar_value_ = varchar_value;
  } else {
    clear_has_varchar_value();
    varchar_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCell.varchar_value)
}

// optional sint64 sint64_value = 2;
inline bool TsCell::has_sint64_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCell::set_has_sint64_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCell::clear_has_sint64_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCell::clear_sint64_value() {
  sint64_value_ = GOOGLE_LONGLONG(0);
  clear_has_sint64_value();
}
inline ::google::protobuf::int64 TsCell::sint64_value() const {
  // @@protoc_insertion_point(field_get:TsCell.sint64_value)
  return sint64_value_;
}
inline void TsCell::set_sint64_value(::google::protobuf::int64 value) {
  set_has_sint64_value();
  sint64_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.sint64_value)
}

// optional sint64 timestamp_value = 3;
inline bool TsCell::has_timestamp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCell::set_has_timestamp_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCell::clear_has_timestamp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCell::clear_timestamp_value() {
  timestamp_value_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_value();
}
inline ::google::protobuf::int64 TsCell::timestamp_value() const {
  // @@protoc_insertion_point(field_get:TsCell.timestamp_value)
  return timestamp_value_;
}
inline void TsCell::set_timestamp_value(::google::protobuf::int64 value) {
  set_has_timestamp_value();
  timestamp_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.timestamp_value)
}

// optional bool boolean_value = 4;
inline bool TsCell::has_boolean_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsCell::set_has_boolean_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsCell::clear_has_boolean_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsCell::clear_boolean_value() {
  boolean_value_ = false;
  clear_has_boolean_value();
}
inline bool TsCell::boolean_value() const {
  // @@protoc_insertion_point(field_get:TsCell.boolean_value)
  return boolean_value_;
}
inline void TsCell::set_boolean_value(bool value) {
  set_has_boolean_value();
  boolean_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.boolean_value)
}

// optional double double_value = 5;
inline bool TsCell::has_double_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TsCell::set_has_double_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TsCell::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TsCell::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double TsCell::double_value() const {
  // @@protoc_insertion_point(field_get:TsCell.double_value)
  return double_value_;
}
inline void TsCell::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
  // @@protoc_insertion_point(field_set:TsCell.double_value)
}

// -------------------------------------------------------------------

// TsListKeysReq

// required bytes table = 1;
inline bool TsListKeysReq::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsListKeysReq::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsListKeysReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsListKeysReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsListKeysReq::table() const {
  // @@protoc_insertion_point(field_get:TsListKeysReq.table)
  return *table_;
}
inline void TsListKeysReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsListKeysReq.table)
}
inline void TsListKeysReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsListKeysReq.table)
}
inline void TsListKeysReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsListKeysReq.table)
}
inline ::std::string* TsListKeysReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsListKeysReq.table)
  return table_;
}
inline ::std::string* TsListKeysReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsListKeysReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsListKeysReq.table)
}

// optional uint32 timeout = 2;
inline bool TsListKeysReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsListKeysReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsListKeysReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsListKeysReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TsListKeysReq::timeout() const {
  // @@protoc_insertion_point(field_get:TsListKeysReq.timeout)
  return timeout_;
}
inline void TsListKeysReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:TsListKeysReq.timeout)
}

// -------------------------------------------------------------------

// TsListKeysResp

// repeated .TsRow keys = 1;
inline int TsListKeysResp::keys_size() const {
  return keys_.size();
}
inline void TsListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::TsRow& TsListKeysResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:TsListKeysResp.keys)
  return keys_.Get(index);
}
inline ::TsRow* TsListKeysResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:TsListKeysResp.keys)
  return keys_.Mutable(index);
}
inline ::TsRow* TsListKeysResp::add_keys() {
  // @@protoc_insertion_point(field_add:TsListKeysResp.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsRow >&
TsListKeysResp::keys() const {
  // @@protoc_insertion_point(field_list:TsListKeysResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsRow >*
TsListKeysResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:TsListKeysResp.keys)
  return &keys_;
}

// optional bool done = 2;
inline bool TsListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool TsListKeysResp::done() const {
  // @@protoc_insertion_point(field_get:TsListKeysResp.done)
  return done_;
}
inline void TsListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:TsListKeysResp.done)
}

// -------------------------------------------------------------------

// TsCoverageReq

// optional .TsInterpolation query = 1;
inline bool TsCoverageReq::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCoverageReq::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCoverageReq::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCoverageReq::clear_query() {
  if (query_ != NULL) query_->::TsInterpolation::Clear();
  clear_has_query();
}
inline const ::TsInterpolation& TsCoverageReq::query() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.query)
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::TsInterpolation* TsCoverageReq::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::TsInterpolation;
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.query)
  return query_;
}
inline ::TsInterpolation* TsCoverageReq::release_query() {
  clear_has_query();
  ::TsInterpolation* temp = query_;
  query_ = NULL;
  return temp;
}
inline void TsCoverageReq::set_allocated_query(::TsInterpolation* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.query)
}

// required bytes table = 2;
inline bool TsCoverageReq::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCoverageReq::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCoverageReq::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCoverageReq::clear_table() {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& TsCoverageReq::table() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.table)
  return *table_;
}
inline void TsCoverageReq::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageReq.table)
}
inline void TsCoverageReq::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.table)
}
inline void TsCoverageReq::set_table(const void* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.table)
}
inline ::std::string* TsCoverageReq::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.table)
  return table_;
}
inline ::std::string* TsCoverageReq::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageReq::set_allocated_table(::std::string* table) {
  if (table_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_;
  }
  if (table) {
    set_has_table();
    table_ = table;
  } else {
    clear_has_table();
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.table)
}

// optional bytes replace_cover = 3;
inline bool TsCoverageReq::has_replace_cover() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCoverageReq::set_has_replace_cover() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCoverageReq::clear_has_replace_cover() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCoverageReq::clear_replace_cover() {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_->clear();
  }
  clear_has_replace_cover();
}
inline const ::std::string& TsCoverageReq::replace_cover() const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.replace_cover)
  return *replace_cover_;
}
inline void TsCoverageReq::set_replace_cover(const ::std::string& value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageReq.replace_cover)
}
inline void TsCoverageReq::set_replace_cover(const char* value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.replace_cover)
}
inline void TsCoverageReq::set_replace_cover(const void* value, size_t size) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.replace_cover)
}
inline ::std::string* TsCoverageReq::mutable_replace_cover() {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.replace_cover)
  return replace_cover_;
}
inline ::std::string* TsCoverageReq::release_replace_cover() {
  clear_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = replace_cover_;
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageReq::set_allocated_replace_cover(::std::string* replace_cover) {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete replace_cover_;
  }
  if (replace_cover) {
    set_has_replace_cover();
    replace_cover_ = replace_cover;
  } else {
    clear_has_replace_cover();
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageReq.replace_cover)
}

// repeated bytes unavailable_cover = 4;
inline int TsCoverageReq::unavailable_cover_size() const {
  return unavailable_cover_.size();
}
inline void TsCoverageReq::clear_unavailable_cover() {
  unavailable_cover_.Clear();
}
inline const ::std::string& TsCoverageReq::unavailable_cover(int index) const {
  // @@protoc_insertion_point(field_get:TsCoverageReq.unavailable_cover)
  return unavailable_cover_.Get(index);
}
inline ::std::string* TsCoverageReq::mutable_unavailable_cover(int index) {
  // @@protoc_insertion_point(field_mutable:TsCoverageReq.unavailable_cover)
  return unavailable_cover_.Mutable(index);
}
inline void TsCoverageReq::set_unavailable_cover(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TsCoverageReq.unavailable_cover)
  unavailable_cover_.Mutable(index)->assign(value);
}
inline void TsCoverageReq::set_unavailable_cover(int index, const char* value) {
  unavailable_cover_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::set_unavailable_cover(int index, const void* value, size_t size) {
  unavailable_cover_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageReq.unavailable_cover)
}
inline ::std::string* TsCoverageReq::add_unavailable_cover() {
  return unavailable_cover_.Add();
}
inline void TsCoverageReq::add_unavailable_cover(const ::std::string& value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::add_unavailable_cover(const char* value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TsCoverageReq.unavailable_cover)
}
inline void TsCoverageReq::add_unavailable_cover(const void* value, size_t size) {
  unavailable_cover_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TsCoverageReq.unavailable_cover)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TsCoverageReq::unavailable_cover() const {
  // @@protoc_insertion_point(field_list:TsCoverageReq.unavailable_cover)
  return unavailable_cover_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TsCoverageReq::mutable_unavailable_cover() {
  // @@protoc_insertion_point(field_mutable_list:TsCoverageReq.unavailable_cover)
  return &unavailable_cover_;
}

// -------------------------------------------------------------------

// TsCoverageResp

// repeated .TsCoverageEntry entries = 1;
inline int TsCoverageResp::entries_size() const {
  return entries_.size();
}
inline void TsCoverageResp::clear_entries() {
  entries_.Clear();
}
inline const ::TsCoverageEntry& TsCoverageResp::entries(int index) const {
  // @@protoc_insertion_point(field_get:TsCoverageResp.entries)
  return entries_.Get(index);
}
inline ::TsCoverageEntry* TsCoverageResp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TsCoverageResp.entries)
  return entries_.Mutable(index);
}
inline ::TsCoverageEntry* TsCoverageResp::add_entries() {
  // @@protoc_insertion_point(field_add:TsCoverageResp.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >&
TsCoverageResp::entries() const {
  // @@protoc_insertion_point(field_list:TsCoverageResp.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TsCoverageEntry >*
TsCoverageResp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TsCoverageResp.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// TsCoverageEntry

// required bytes ip = 1;
inline bool TsCoverageEntry::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsCoverageEntry::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsCoverageEntry::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsCoverageEntry::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TsCoverageEntry::ip() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.ip)
  return *ip_;
}
inline void TsCoverageEntry::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageEntry.ip)
}
inline void TsCoverageEntry::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageEntry.ip)
}
inline void TsCoverageEntry::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageEntry.ip)
}
inline ::std::string* TsCoverageEntry::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.ip)
  return ip_;
}
inline ::std::string* TsCoverageEntry::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageEntry::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.ip)
}

// required uint32 port = 2;
inline bool TsCoverageEntry::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsCoverageEntry::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsCoverageEntry::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsCoverageEntry::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TsCoverageEntry::port() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.port)
  return port_;
}
inline void TsCoverageEntry::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:TsCoverageEntry.port)
}

// required bytes cover_context = 3;
inline bool TsCoverageEntry::has_cover_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsCoverageEntry::set_has_cover_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsCoverageEntry::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsCoverageEntry::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& TsCoverageEntry::cover_context() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.cover_context)
  return *cover_context_;
}
inline void TsCoverageEntry::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:TsCoverageEntry.cover_context)
}
inline void TsCoverageEntry::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsCoverageEntry.cover_context)
}
inline void TsCoverageEntry::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsCoverageEntry.cover_context)
}
inline ::std::string* TsCoverageEntry::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.cover_context)
  return cover_context_;
}
inline ::std::string* TsCoverageEntry::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsCoverageEntry::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.cover_context)
}

// optional .TsRange range = 4;
inline bool TsCoverageEntry::has_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsCoverageEntry::set_has_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsCoverageEntry::clear_has_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsCoverageEntry::clear_range() {
  if (range_ != NULL) range_->::TsRange::Clear();
  clear_has_range();
}
inline const ::TsRange& TsCoverageEntry::range() const {
  // @@protoc_insertion_point(field_get:TsCoverageEntry.range)
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::TsRange* TsCoverageEntry::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::TsRange;
  // @@protoc_insertion_point(field_mutable:TsCoverageEntry.range)
  return range_;
}
inline ::TsRange* TsCoverageEntry::release_range() {
  clear_has_range();
  ::TsRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void TsCoverageEntry::set_allocated_range(::TsRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
  // @@protoc_insertion_point(field_set_allocated:TsCoverageEntry.range)
}

// -------------------------------------------------------------------

// TsRange

// required bytes field_name = 1;
inline bool TsRange::has_field_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TsRange::set_has_field_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TsRange::clear_has_field_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TsRange::clear_field_name() {
  if (field_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_->clear();
  }
  clear_has_field_name();
}
inline const ::std::string& TsRange::field_name() const {
  // @@protoc_insertion_point(field_get:TsRange.field_name)
  return *field_name_;
}
inline void TsRange::set_field_name(const ::std::string& value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
  // @@protoc_insertion_point(field_set:TsRange.field_name)
}
inline void TsRange::set_field_name(const char* value) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsRange.field_name)
}
inline void TsRange::set_field_name(const void* value, size_t size) {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  field_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsRange.field_name)
}
inline ::std::string* TsRange::mutable_field_name() {
  set_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsRange.field_name)
  return field_name_;
}
inline ::std::string* TsRange::release_field_name() {
  clear_has_field_name();
  if (field_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = field_name_;
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsRange::set_allocated_field_name(::std::string* field_name) {
  if (field_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete field_name_;
  }
  if (field_name) {
    set_has_field_name();
    field_name_ = field_name;
  } else {
    clear_has_field_name();
    field_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsRange.field_name)
}

// required sint64 lower_bound = 2;
inline bool TsRange::has_lower_bound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TsRange::set_has_lower_bound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TsRange::clear_has_lower_bound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TsRange::clear_lower_bound() {
  lower_bound_ = GOOGLE_LONGLONG(0);
  clear_has_lower_bound();
}
inline ::google::protobuf::int64 TsRange::lower_bound() const {
  // @@protoc_insertion_point(field_get:TsRange.lower_bound)
  return lower_bound_;
}
inline void TsRange::set_lower_bound(::google::protobuf::int64 value) {
  set_has_lower_bound();
  lower_bound_ = value;
  // @@protoc_insertion_point(field_set:TsRange.lower_bound)
}

// required bool lower_bound_inclusive = 3;
inline bool TsRange::has_lower_bound_inclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TsRange::set_has_lower_bound_inclusive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TsRange::clear_has_lower_bound_inclusive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TsRange::clear_lower_bound_inclusive() {
  lower_bound_inclusive_ = false;
  clear_has_lower_bound_inclusive();
}
inline bool TsRange::lower_bound_inclusive() const {
  // @@protoc_insertion_point(field_get:TsRange.lower_bound_inclusive)
  return lower_bound_inclusive_;
}
inline void TsRange::set_lower_bound_inclusive(bool value) {
  set_has_lower_bound_inclusive();
  lower_bound_inclusive_ = value;
  // @@protoc_insertion_point(field_set:TsRange.lower_bound_inclusive)
}

// required sint64 upper_bound = 4;
inline bool TsRange::has_upper_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TsRange::set_has_upper_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TsRange::clear_has_upper_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TsRange::clear_upper_bound() {
  upper_bound_ = GOOGLE_LONGLONG(0);
  clear_has_upper_bound();
}
inline ::google::protobuf::int64 TsRange::upper_bound() const {
  // @@protoc_insertion_point(field_get:TsRange.upper_bound)
  return upper_bound_;
}
inline void TsRange::set_upper_bound(::google::protobuf::int64 value) {
  set_has_upper_bound();
  upper_bound_ = value;
  // @@protoc_insertion_point(field_set:TsRange.upper_bound)
}

// required bool upper_bound_inclusive = 5;
inline bool TsRange::has_upper_bound_inclusive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TsRange::set_has_upper_bound_inclusive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TsRange::clear_has_upper_bound_inclusive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TsRange::clear_upper_bound_inclusive() {
  upper_bound_inclusive_ = false;
  clear_has_upper_bound_inclusive();
}
inline bool TsRange::upper_bound_inclusive() const {
  // @@protoc_insertion_point(field_get:TsRange.upper_bound_inclusive)
  return upper_bound_inclusive_;
}
inline void TsRange::set_upper_bound_inclusive(bool value) {
  set_has_upper_bound_inclusive();
  upper_bound_inclusive_ = value;
  // @@protoc_insertion_point(field_set:TsRange.upper_bound_inclusive)
}

// required bytes desc = 6;
inline bool TsRange::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TsRange::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TsRange::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TsRange::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TsRange::desc() const {
  // @@protoc_insertion_point(field_get:TsRange.desc)
  return *desc_;
}
inline void TsRange::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:TsRange.desc)
}
inline void TsRange::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:TsRange.desc)
}
inline void TsRange::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TsRange.desc)
}
inline ::std::string* TsRange::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TsRange.desc)
  return desc_;
}
inline ::std::string* TsRange::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TsRange::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TsRange.desc)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TsColumnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TsColumnType>() {
  return ::TsColumnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_5fts_2eproto__INCLUDED
