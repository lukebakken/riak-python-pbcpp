// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak_dt.proto

#ifndef PROTOBUF_riak_5fdt_2eproto__INCLUDED
#define PROTOBUF_riak_5fdt_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_5fdt_2eproto();
void protobuf_AssignDesc_riak_5fdt_2eproto();
void protobuf_ShutdownFile_riak_5fdt_2eproto();

class MapField;
class MapEntry;
class DtFetchReq;
class DtValue;
class DtFetchResp;
class CounterOp;
class SetOp;
class MapUpdate;
class MapOp;
class DtOp;
class DtUpdateReq;
class DtUpdateResp;

enum MapField_MapFieldType {
  MapField_MapFieldType_COUNTER = 1,
  MapField_MapFieldType_SET = 2,
  MapField_MapFieldType_REGISTER = 3,
  MapField_MapFieldType_FLAG = 4,
  MapField_MapFieldType_MAP = 5
};
bool MapField_MapFieldType_IsValid(int value);
const MapField_MapFieldType MapField_MapFieldType_MapFieldType_MIN = MapField_MapFieldType_COUNTER;
const MapField_MapFieldType MapField_MapFieldType_MapFieldType_MAX = MapField_MapFieldType_MAP;
const int MapField_MapFieldType_MapFieldType_ARRAYSIZE = MapField_MapFieldType_MapFieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapField_MapFieldType_descriptor();
inline const ::std::string& MapField_MapFieldType_Name(MapField_MapFieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapField_MapFieldType_descriptor(), value);
}
inline bool MapField_MapFieldType_Parse(
    const ::std::string& name, MapField_MapFieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapField_MapFieldType>(
    MapField_MapFieldType_descriptor(), name, value);
}
enum DtFetchResp_DataType {
  DtFetchResp_DataType_COUNTER = 1,
  DtFetchResp_DataType_SET = 2,
  DtFetchResp_DataType_MAP = 3
};
bool DtFetchResp_DataType_IsValid(int value);
const DtFetchResp_DataType DtFetchResp_DataType_DataType_MIN = DtFetchResp_DataType_COUNTER;
const DtFetchResp_DataType DtFetchResp_DataType_DataType_MAX = DtFetchResp_DataType_MAP;
const int DtFetchResp_DataType_DataType_ARRAYSIZE = DtFetchResp_DataType_DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DtFetchResp_DataType_descriptor();
inline const ::std::string& DtFetchResp_DataType_Name(DtFetchResp_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DtFetchResp_DataType_descriptor(), value);
}
inline bool DtFetchResp_DataType_Parse(
    const ::std::string& name, DtFetchResp_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DtFetchResp_DataType>(
    DtFetchResp_DataType_descriptor(), name, value);
}
enum MapUpdate_FlagOp {
  MapUpdate_FlagOp_ENABLE = 1,
  MapUpdate_FlagOp_DISABLE = 2
};
bool MapUpdate_FlagOp_IsValid(int value);
const MapUpdate_FlagOp MapUpdate_FlagOp_FlagOp_MIN = MapUpdate_FlagOp_ENABLE;
const MapUpdate_FlagOp MapUpdate_FlagOp_FlagOp_MAX = MapUpdate_FlagOp_DISABLE;
const int MapUpdate_FlagOp_FlagOp_ARRAYSIZE = MapUpdate_FlagOp_FlagOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapUpdate_FlagOp_descriptor();
inline const ::std::string& MapUpdate_FlagOp_Name(MapUpdate_FlagOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapUpdate_FlagOp_descriptor(), value);
}
inline bool MapUpdate_FlagOp_Parse(
    const ::std::string& name, MapUpdate_FlagOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapUpdate_FlagOp>(
    MapUpdate_FlagOp_descriptor(), name, value);
}
// ===================================================================

class MapField : public ::google::protobuf::Message {
 public:
  MapField();
  virtual ~MapField();

  MapField(const MapField& from);

  inline MapField& operator=(const MapField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapField& default_instance();

  void Swap(MapField* other);

  // implements Message ----------------------------------------------

  MapField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapField& from);
  void MergeFrom(const MapField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MapField_MapFieldType MapFieldType;
  static const MapFieldType COUNTER = MapField_MapFieldType_COUNTER;
  static const MapFieldType SET = MapField_MapFieldType_SET;
  static const MapFieldType REGISTER = MapField_MapFieldType_REGISTER;
  static const MapFieldType FLAG = MapField_MapFieldType_FLAG;
  static const MapFieldType MAP = MapField_MapFieldType_MAP;
  static inline bool MapFieldType_IsValid(int value) {
    return MapField_MapFieldType_IsValid(value);
  }
  static const MapFieldType MapFieldType_MIN =
    MapField_MapFieldType_MapFieldType_MIN;
  static const MapFieldType MapFieldType_MAX =
    MapField_MapFieldType_MapFieldType_MAX;
  static const int MapFieldType_ARRAYSIZE =
    MapField_MapFieldType_MapFieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MapFieldType_descriptor() {
    return MapField_MapFieldType_descriptor();
  }
  static inline const ::std::string& MapFieldType_Name(MapFieldType value) {
    return MapField_MapFieldType_Name(value);
  }
  static inline bool MapFieldType_Parse(const ::std::string& name,
      MapFieldType* value) {
    return MapField_MapFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .MapField.MapFieldType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::MapField_MapFieldType type() const;
  inline void set_type(::MapField_MapFieldType value);

  // @@protoc_insertion_point(class_scope:MapField)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static MapField* default_instance_;
};
// -------------------------------------------------------------------

class MapEntry : public ::google::protobuf::Message {
 public:
  MapEntry();
  virtual ~MapEntry();

  MapEntry(const MapEntry& from);

  inline MapEntry& operator=(const MapEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntry& default_instance();

  void Swap(MapEntry* other);

  // implements Message ----------------------------------------------

  MapEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapEntry& from);
  void MergeFrom(const MapEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MapField field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::MapField& field() const;
  inline ::MapField* mutable_field();
  inline ::MapField* release_field();
  inline void set_allocated_field(::MapField* field);

  // optional sint64 counter_value = 2;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 2;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 3;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 3;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // optional bytes register_value = 4;
  inline bool has_register_value() const;
  inline void clear_register_value();
  static const int kRegisterValueFieldNumber = 4;
  inline const ::std::string& register_value() const;
  inline void set_register_value(const ::std::string& value);
  inline void set_register_value(const char* value);
  inline void set_register_value(const void* value, size_t size);
  inline ::std::string* mutable_register_value();
  inline ::std::string* release_register_value();
  inline void set_allocated_register_value(::std::string* register_value);

  // optional bool flag_value = 5;
  inline bool has_flag_value() const;
  inline void clear_flag_value();
  static const int kFlagValueFieldNumber = 5;
  inline bool flag_value() const;
  inline void set_flag_value(bool value);

  // repeated .MapEntry map_value = 6;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 6;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:MapEntry)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_counter_value();
  inline void clear_has_counter_value();
  inline void set_has_register_value();
  inline void clear_has_register_value();
  inline void set_has_flag_value();
  inline void clear_has_flag_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MapField* field_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::std::string* register_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  bool flag_value_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static MapEntry* default_instance_;
};
// -------------------------------------------------------------------

class DtFetchReq : public ::google::protobuf::Message {
 public:
  DtFetchReq();
  virtual ~DtFetchReq();

  DtFetchReq(const DtFetchReq& from);

  inline DtFetchReq& operator=(const DtFetchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtFetchReq& default_instance();

  void Swap(DtFetchReq* other);

  // implements Message ----------------------------------------------

  DtFetchReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtFetchReq& from);
  void MergeFrom(const DtFetchReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional uint32 r = 4;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 4;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 5;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 5;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 6;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 6;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 7;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 7;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // optional uint32 timeout = 8;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 9;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 9;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 10;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 10;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool include_context = 11 [default = true];
  inline bool has_include_context() const;
  inline void clear_include_context();
  static const int kIncludeContextFieldNumber = 11;
  inline bool include_context() const;
  inline void set_include_context(bool value);

  // @@protoc_insertion_point(class_scope:DtFetchReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_include_context();
  inline void clear_has_include_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 timeout_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool sloppy_quorum_;
  bool include_context_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtFetchReq* default_instance_;
};
// -------------------------------------------------------------------

class DtValue : public ::google::protobuf::Message {
 public:
  DtValue();
  virtual ~DtValue();

  DtValue(const DtValue& from);

  inline DtValue& operator=(const DtValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtValue& default_instance();

  void Swap(DtValue* other);

  // implements Message ----------------------------------------------

  DtValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtValue& from);
  void MergeFrom(const DtValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 counter_value = 1;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 1;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 2;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 2;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // repeated .MapEntry map_value = 3;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 3;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:DtValue)
 private:
  inline void set_has_counter_value();
  inline void clear_has_counter_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtValue* default_instance_;
};
// -------------------------------------------------------------------

class DtFetchResp : public ::google::protobuf::Message {
 public:
  DtFetchResp();
  virtual ~DtFetchResp();

  DtFetchResp(const DtFetchResp& from);

  inline DtFetchResp& operator=(const DtFetchResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtFetchResp& default_instance();

  void Swap(DtFetchResp* other);

  // implements Message ----------------------------------------------

  DtFetchResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtFetchResp& from);
  void MergeFrom(const DtFetchResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DtFetchResp_DataType DataType;
  static const DataType COUNTER = DtFetchResp_DataType_COUNTER;
  static const DataType SET = DtFetchResp_DataType_SET;
  static const DataType MAP = DtFetchResp_DataType_MAP;
  static inline bool DataType_IsValid(int value) {
    return DtFetchResp_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    DtFetchResp_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    DtFetchResp_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    DtFetchResp_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return DtFetchResp_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return DtFetchResp_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return DtFetchResp_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes context = 1;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 1;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required .DtFetchResp.DataType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::DtFetchResp_DataType type() const;
  inline void set_type(::DtFetchResp_DataType value);

  // optional .DtValue value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::DtValue& value() const;
  inline ::DtValue* mutable_value();
  inline ::DtValue* release_value();
  inline void set_allocated_value(::DtValue* value);

  // @@protoc_insertion_point(class_scope:DtFetchResp)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* context_;
  ::DtValue* value_;
  int type_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtFetchResp* default_instance_;
};
// -------------------------------------------------------------------

class CounterOp : public ::google::protobuf::Message {
 public:
  CounterOp();
  virtual ~CounterOp();

  CounterOp(const CounterOp& from);

  inline CounterOp& operator=(const CounterOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterOp& default_instance();

  void Swap(CounterOp* other);

  // implements Message ----------------------------------------------

  CounterOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterOp& from);
  void MergeFrom(const CounterOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 increment = 1;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 1;
  inline ::google::protobuf::int64 increment() const;
  inline void set_increment(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CounterOp)
 private:
  inline void set_has_increment();
  inline void clear_has_increment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 increment_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static CounterOp* default_instance_;
};
// -------------------------------------------------------------------

class SetOp : public ::google::protobuf::Message {
 public:
  SetOp();
  virtual ~SetOp();

  SetOp(const SetOp& from);

  inline SetOp& operator=(const SetOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOp& default_instance();

  void Swap(SetOp* other);

  // implements Message ----------------------------------------------

  SetOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOp& from);
  void MergeFrom(const SetOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes adds = 1;
  inline int adds_size() const;
  inline void clear_adds();
  static const int kAddsFieldNumber = 1;
  inline const ::std::string& adds(int index) const;
  inline ::std::string* mutable_adds(int index);
  inline void set_adds(int index, const ::std::string& value);
  inline void set_adds(int index, const char* value);
  inline void set_adds(int index, const void* value, size_t size);
  inline ::std::string* add_adds();
  inline void add_adds(const ::std::string& value);
  inline void add_adds(const char* value);
  inline void add_adds(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& adds() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_adds();

  // repeated bytes removes = 2;
  inline int removes_size() const;
  inline void clear_removes();
  static const int kRemovesFieldNumber = 2;
  inline const ::std::string& removes(int index) const;
  inline ::std::string* mutable_removes(int index);
  inline void set_removes(int index, const ::std::string& value);
  inline void set_removes(int index, const char* value);
  inline void set_removes(int index, const void* value, size_t size);
  inline ::std::string* add_removes();
  inline void add_removes(const ::std::string& value);
  inline void add_removes(const char* value);
  inline void add_removes(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& removes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_removes();

  // @@protoc_insertion_point(class_scope:SetOp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> adds_;
  ::google::protobuf::RepeatedPtrField< ::std::string> removes_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static SetOp* default_instance_;
};
// -------------------------------------------------------------------

class MapUpdate : public ::google::protobuf::Message {
 public:
  MapUpdate();
  virtual ~MapUpdate();

  MapUpdate(const MapUpdate& from);

  inline MapUpdate& operator=(const MapUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapUpdate& default_instance();

  void Swap(MapUpdate* other);

  // implements Message ----------------------------------------------

  MapUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapUpdate& from);
  void MergeFrom(const MapUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MapUpdate_FlagOp FlagOp;
  static const FlagOp ENABLE = MapUpdate_FlagOp_ENABLE;
  static const FlagOp DISABLE = MapUpdate_FlagOp_DISABLE;
  static inline bool FlagOp_IsValid(int value) {
    return MapUpdate_FlagOp_IsValid(value);
  }
  static const FlagOp FlagOp_MIN =
    MapUpdate_FlagOp_FlagOp_MIN;
  static const FlagOp FlagOp_MAX =
    MapUpdate_FlagOp_FlagOp_MAX;
  static const int FlagOp_ARRAYSIZE =
    MapUpdate_FlagOp_FlagOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlagOp_descriptor() {
    return MapUpdate_FlagOp_descriptor();
  }
  static inline const ::std::string& FlagOp_Name(FlagOp value) {
    return MapUpdate_FlagOp_Name(value);
  }
  static inline bool FlagOp_Parse(const ::std::string& name,
      FlagOp* value) {
    return MapUpdate_FlagOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MapField field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::MapField& field() const;
  inline ::MapField* mutable_field();
  inline ::MapField* release_field();
  inline void set_allocated_field(::MapField* field);

  // optional .CounterOp counter_op = 2;
  inline bool has_counter_op() const;
  inline void clear_counter_op();
  static const int kCounterOpFieldNumber = 2;
  inline const ::CounterOp& counter_op() const;
  inline ::CounterOp* mutable_counter_op();
  inline ::CounterOp* release_counter_op();
  inline void set_allocated_counter_op(::CounterOp* counter_op);

  // optional .SetOp set_op = 3;
  inline bool has_set_op() const;
  inline void clear_set_op();
  static const int kSetOpFieldNumber = 3;
  inline const ::SetOp& set_op() const;
  inline ::SetOp* mutable_set_op();
  inline ::SetOp* release_set_op();
  inline void set_allocated_set_op(::SetOp* set_op);

  // optional bytes register_op = 4;
  inline bool has_register_op() const;
  inline void clear_register_op();
  static const int kRegisterOpFieldNumber = 4;
  inline const ::std::string& register_op() const;
  inline void set_register_op(const ::std::string& value);
  inline void set_register_op(const char* value);
  inline void set_register_op(const void* value, size_t size);
  inline ::std::string* mutable_register_op();
  inline ::std::string* release_register_op();
  inline void set_allocated_register_op(::std::string* register_op);

  // optional .MapUpdate.FlagOp flag_op = 5;
  inline bool has_flag_op() const;
  inline void clear_flag_op();
  static const int kFlagOpFieldNumber = 5;
  inline ::MapUpdate_FlagOp flag_op() const;
  inline void set_flag_op(::MapUpdate_FlagOp value);

  // optional .MapOp map_op = 6;
  inline bool has_map_op() const;
  inline void clear_map_op();
  static const int kMapOpFieldNumber = 6;
  inline const ::MapOp& map_op() const;
  inline ::MapOp* mutable_map_op();
  inline ::MapOp* release_map_op();
  inline void set_allocated_map_op(::MapOp* map_op);

  // @@protoc_insertion_point(class_scope:MapUpdate)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_counter_op();
  inline void clear_has_counter_op();
  inline void set_has_set_op();
  inline void clear_has_set_op();
  inline void set_has_register_op();
  inline void clear_has_register_op();
  inline void set_has_flag_op();
  inline void clear_has_flag_op();
  inline void set_has_map_op();
  inline void clear_has_map_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MapField* field_;
  ::CounterOp* counter_op_;
  ::SetOp* set_op_;
  ::std::string* register_op_;
  ::MapOp* map_op_;
  int flag_op_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static MapUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MapOp : public ::google::protobuf::Message {
 public:
  MapOp();
  virtual ~MapOp();

  MapOp(const MapOp& from);

  inline MapOp& operator=(const MapOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapOp& default_instance();

  void Swap(MapOp* other);

  // implements Message ----------------------------------------------

  MapOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapOp& from);
  void MergeFrom(const MapOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapField removes = 1;
  inline int removes_size() const;
  inline void clear_removes();
  static const int kRemovesFieldNumber = 1;
  inline const ::MapField& removes(int index) const;
  inline ::MapField* mutable_removes(int index);
  inline ::MapField* add_removes();
  inline const ::google::protobuf::RepeatedPtrField< ::MapField >&
      removes() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapField >*
      mutable_removes();

  // repeated .MapUpdate updates = 2;
  inline int updates_size() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 2;
  inline const ::MapUpdate& updates(int index) const;
  inline ::MapUpdate* mutable_updates(int index);
  inline ::MapUpdate* add_updates();
  inline const ::google::protobuf::RepeatedPtrField< ::MapUpdate >&
      updates() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapUpdate >*
      mutable_updates();

  // @@protoc_insertion_point(class_scope:MapOp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MapField > removes_;
  ::google::protobuf::RepeatedPtrField< ::MapUpdate > updates_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static MapOp* default_instance_;
};
// -------------------------------------------------------------------

class DtOp : public ::google::protobuf::Message {
 public:
  DtOp();
  virtual ~DtOp();

  DtOp(const DtOp& from);

  inline DtOp& operator=(const DtOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtOp& default_instance();

  void Swap(DtOp* other);

  // implements Message ----------------------------------------------

  DtOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtOp& from);
  void MergeFrom(const DtOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CounterOp counter_op = 1;
  inline bool has_counter_op() const;
  inline void clear_counter_op();
  static const int kCounterOpFieldNumber = 1;
  inline const ::CounterOp& counter_op() const;
  inline ::CounterOp* mutable_counter_op();
  inline ::CounterOp* release_counter_op();
  inline void set_allocated_counter_op(::CounterOp* counter_op);

  // optional .SetOp set_op = 2;
  inline bool has_set_op() const;
  inline void clear_set_op();
  static const int kSetOpFieldNumber = 2;
  inline const ::SetOp& set_op() const;
  inline ::SetOp* mutable_set_op();
  inline ::SetOp* release_set_op();
  inline void set_allocated_set_op(::SetOp* set_op);

  // optional .MapOp map_op = 3;
  inline bool has_map_op() const;
  inline void clear_map_op();
  static const int kMapOpFieldNumber = 3;
  inline const ::MapOp& map_op() const;
  inline ::MapOp* mutable_map_op();
  inline ::MapOp* release_map_op();
  inline void set_allocated_map_op(::MapOp* map_op);

  // @@protoc_insertion_point(class_scope:DtOp)
 private:
  inline void set_has_counter_op();
  inline void clear_has_counter_op();
  inline void set_has_set_op();
  inline void clear_has_set_op();
  inline void set_has_map_op();
  inline void clear_has_map_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::CounterOp* counter_op_;
  ::SetOp* set_op_;
  ::MapOp* map_op_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtOp* default_instance_;
};
// -------------------------------------------------------------------

class DtUpdateReq : public ::google::protobuf::Message {
 public:
  DtUpdateReq();
  virtual ~DtUpdateReq();

  DtUpdateReq(const DtUpdateReq& from);

  inline DtUpdateReq& operator=(const DtUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtUpdateReq& default_instance();

  void Swap(DtUpdateReq* other);

  // implements Message ----------------------------------------------

  DtUpdateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtUpdateReq& from);
  void MergeFrom(const DtUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes context = 4;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 4;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // required .DtOp op = 5;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 5;
  inline const ::DtOp& op() const;
  inline ::DtOp* mutable_op();
  inline ::DtOp* release_op();
  inline void set_allocated_op(::DtOp* op);

  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 7;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 7;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool return_body = 9 [default = false];
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 9;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bool include_context = 13 [default = true];
  inline bool has_include_context() const;
  inline void clear_include_context();
  static const int kIncludeContextFieldNumber = 13;
  inline bool include_context() const;
  inline void set_include_context(bool value);

  // @@protoc_insertion_point(class_scope:DtUpdateReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_include_context();
  inline void clear_has_include_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  ::std::string* context_;
  ::DtOp* op_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 timeout_;
  bool return_body_;
  bool sloppy_quorum_;
  bool include_context_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class DtUpdateResp : public ::google::protobuf::Message {
 public:
  DtUpdateResp();
  virtual ~DtUpdateResp();

  DtUpdateResp(const DtUpdateResp& from);

  inline DtUpdateResp& operator=(const DtUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DtUpdateResp& default_instance();

  void Swap(DtUpdateResp* other);

  // implements Message ----------------------------------------------

  DtUpdateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DtUpdateResp& from);
  void MergeFrom(const DtUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::std::string& context() const;
  inline void set_context(const ::std::string& value);
  inline void set_context(const char* value);
  inline void set_context(const void* value, size_t size);
  inline ::std::string* mutable_context();
  inline ::std::string* release_context();
  inline void set_allocated_context(::std::string* context);

  // optional sint64 counter_value = 3;
  inline bool has_counter_value() const;
  inline void clear_counter_value();
  static const int kCounterValueFieldNumber = 3;
  inline ::google::protobuf::int64 counter_value() const;
  inline void set_counter_value(::google::protobuf::int64 value);

  // repeated bytes set_value = 4;
  inline int set_value_size() const;
  inline void clear_set_value();
  static const int kSetValueFieldNumber = 4;
  inline const ::std::string& set_value(int index) const;
  inline ::std::string* mutable_set_value(int index);
  inline void set_set_value(int index, const ::std::string& value);
  inline void set_set_value(int index, const char* value);
  inline void set_set_value(int index, const void* value, size_t size);
  inline ::std::string* add_set_value();
  inline void add_set_value(const ::std::string& value);
  inline void add_set_value(const char* value);
  inline void add_set_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& set_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_set_value();

  // repeated .MapEntry map_value = 5;
  inline int map_value_size() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 5;
  inline const ::MapEntry& map_value(int index) const;
  inline ::MapEntry* mutable_map_value(int index);
  inline ::MapEntry* add_map_value();
  inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
      map_value() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
      mutable_map_value();

  // @@protoc_insertion_point(class_scope:DtUpdateResp)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_counter_value();
  inline void clear_has_counter_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* context_;
  ::google::protobuf::int64 counter_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> set_value_;
  ::google::protobuf::RepeatedPtrField< ::MapEntry > map_value_;
  friend void  protobuf_AddDesc_riak_5fdt_2eproto();
  friend void protobuf_AssignDesc_riak_5fdt_2eproto();
  friend void protobuf_ShutdownFile_riak_5fdt_2eproto();

  void InitAsDefaultInstance();
  static DtUpdateResp* default_instance_;
};
// ===================================================================


// ===================================================================

// MapField

// required bytes name = 1;
inline bool MapField::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapField::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapField::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapField::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapField::name() const {
  // @@protoc_insertion_point(field_get:MapField.name)
  return *name_;
}
inline void MapField::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:MapField.name)
}
inline void MapField::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapField.name)
}
inline void MapField::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapField.name)
}
inline ::std::string* MapField::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapField.name)
  return name_;
}
inline ::std::string* MapField::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapField::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapField.name)
}

// required .MapField.MapFieldType type = 2;
inline bool MapField::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapField::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapField::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapField::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::MapField_MapFieldType MapField::type() const {
  // @@protoc_insertion_point(field_get:MapField.type)
  return static_cast< ::MapField_MapFieldType >(type_);
}
inline void MapField::set_type(::MapField_MapFieldType value) {
  assert(::MapField_MapFieldType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MapField.type)
}

// -------------------------------------------------------------------

// MapEntry

// required .MapField field = 1;
inline bool MapEntry::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEntry::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEntry::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEntry::clear_field() {
  if (field_ != NULL) field_->::MapField::Clear();
  clear_has_field();
}
inline const ::MapField& MapEntry::field() const {
  // @@protoc_insertion_point(field_get:MapEntry.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::MapField* MapEntry::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::MapField;
  // @@protoc_insertion_point(field_mutable:MapEntry.field)
  return field_;
}
inline ::MapField* MapEntry::release_field() {
  clear_has_field();
  ::MapField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void MapEntry::set_allocated_field(::MapField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntry.field)
}

// optional sint64 counter_value = 2;
inline bool MapEntry::has_counter_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapEntry::set_has_counter_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapEntry::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapEntry::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 MapEntry::counter_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.counter_value)
  return counter_value_;
}
inline void MapEntry::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:MapEntry.counter_value)
}

// repeated bytes set_value = 3;
inline int MapEntry::set_value_size() const {
  return set_value_.size();
}
inline void MapEntry::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& MapEntry::set_value(int index) const {
  // @@protoc_insertion_point(field_get:MapEntry.set_value)
  return set_value_.Get(index);
}
inline ::std::string* MapEntry::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:MapEntry.set_value)
  return set_value_.Mutable(index);
}
inline void MapEntry::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MapEntry.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void MapEntry::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntry.set_value)
}
inline void MapEntry::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntry.set_value)
}
inline ::std::string* MapEntry::add_set_value() {
  return set_value_.Add();
}
inline void MapEntry::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MapEntry.set_value)
}
inline void MapEntry::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MapEntry.set_value)
}
inline void MapEntry::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MapEntry.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapEntry::set_value() const {
  // @@protoc_insertion_point(field_list:MapEntry.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapEntry::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:MapEntry.set_value)
  return &set_value_;
}

// optional bytes register_value = 4;
inline bool MapEntry::has_register_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapEntry::set_has_register_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapEntry::clear_has_register_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapEntry::clear_register_value() {
  if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_->clear();
  }
  clear_has_register_value();
}
inline const ::std::string& MapEntry::register_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.register_value)
  return *register_value_;
}
inline void MapEntry::set_register_value(const ::std::string& value) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(value);
  // @@protoc_insertion_point(field_set:MapEntry.register_value)
}
inline void MapEntry::set_register_value(const char* value) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapEntry.register_value)
}
inline void MapEntry::set_register_value(const void* value, size_t size) {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  register_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapEntry.register_value)
}
inline ::std::string* MapEntry::mutable_register_value() {
  set_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapEntry.register_value)
  return register_value_;
}
inline ::std::string* MapEntry::release_register_value() {
  clear_has_register_value();
  if (register_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_value_;
    register_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapEntry::set_allocated_register_value(::std::string* register_value) {
  if (register_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_value_;
  }
  if (register_value) {
    set_has_register_value();
    register_value_ = register_value;
  } else {
    clear_has_register_value();
    register_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapEntry.register_value)
}

// optional bool flag_value = 5;
inline bool MapEntry::has_flag_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapEntry::set_has_flag_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapEntry::clear_has_flag_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapEntry::clear_flag_value() {
  flag_value_ = false;
  clear_has_flag_value();
}
inline bool MapEntry::flag_value() const {
  // @@protoc_insertion_point(field_get:MapEntry.flag_value)
  return flag_value_;
}
inline void MapEntry::set_flag_value(bool value) {
  set_has_flag_value();
  flag_value_ = value;
  // @@protoc_insertion_point(field_set:MapEntry.flag_value)
}

// repeated .MapEntry map_value = 6;
inline int MapEntry::map_value_size() const {
  return map_value_.size();
}
inline void MapEntry::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& MapEntry::map_value(int index) const {
  // @@protoc_insertion_point(field_get:MapEntry.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* MapEntry::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:MapEntry.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* MapEntry::add_map_value() {
  // @@protoc_insertion_point(field_add:MapEntry.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
MapEntry::map_value() const {
  // @@protoc_insertion_point(field_list:MapEntry.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
MapEntry::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:MapEntry.map_value)
  return &map_value_;
}

// -------------------------------------------------------------------

// DtFetchReq

// required bytes bucket = 1;
inline bool DtFetchReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtFetchReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtFetchReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtFetchReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& DtFetchReq::bucket() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.bucket)
  return *bucket_;
}
inline void DtFetchReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.bucket)
}
inline void DtFetchReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.bucket)
}
inline void DtFetchReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.bucket)
}
inline ::std::string* DtFetchReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.bucket)
  return bucket_;
}
inline ::std::string* DtFetchReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.bucket)
}

// required bytes key = 2;
inline bool DtFetchReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtFetchReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtFetchReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtFetchReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtFetchReq::key() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.key)
  return *key_;
}
inline void DtFetchReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.key)
}
inline void DtFetchReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.key)
}
inline void DtFetchReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.key)
}
inline ::std::string* DtFetchReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.key)
  return key_;
}
inline ::std::string* DtFetchReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.key)
}

// required bytes type = 3;
inline bool DtFetchReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtFetchReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtFetchReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtFetchReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DtFetchReq::type() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.type)
  return *type_;
}
inline void DtFetchReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchReq.type)
}
inline void DtFetchReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchReq.type)
}
inline void DtFetchReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchReq.type)
}
inline ::std::string* DtFetchReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchReq.type)
  return type_;
}
inline ::std::string* DtFetchReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchReq.type)
}

// optional uint32 r = 4;
inline bool DtFetchReq::has_r() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DtFetchReq::set_has_r() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DtFetchReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DtFetchReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 DtFetchReq::r() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.r)
  return r_;
}
inline void DtFetchReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.r)
}

// optional uint32 pr = 5;
inline bool DtFetchReq::has_pr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DtFetchReq::set_has_pr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DtFetchReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DtFetchReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 DtFetchReq::pr() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.pr)
  return pr_;
}
inline void DtFetchReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.pr)
}

// optional bool basic_quorum = 6;
inline bool DtFetchReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DtFetchReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DtFetchReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DtFetchReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool DtFetchReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.basic_quorum)
  return basic_quorum_;
}
inline void DtFetchReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.basic_quorum)
}

// optional bool notfound_ok = 7;
inline bool DtFetchReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DtFetchReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DtFetchReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DtFetchReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool DtFetchReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.notfound_ok)
  return notfound_ok_;
}
inline void DtFetchReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.notfound_ok)
}

// optional uint32 timeout = 8;
inline bool DtFetchReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DtFetchReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DtFetchReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DtFetchReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 DtFetchReq::timeout() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.timeout)
  return timeout_;
}
inline void DtFetchReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.timeout)
}

// optional bool sloppy_quorum = 9;
inline bool DtFetchReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DtFetchReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DtFetchReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DtFetchReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool DtFetchReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void DtFetchReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.sloppy_quorum)
}

// optional uint32 n_val = 10;
inline bool DtFetchReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DtFetchReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DtFetchReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DtFetchReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 DtFetchReq::n_val() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.n_val)
  return n_val_;
}
inline void DtFetchReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.n_val)
}

// optional bool include_context = 11 [default = true];
inline bool DtFetchReq::has_include_context() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DtFetchReq::set_has_include_context() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DtFetchReq::clear_has_include_context() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DtFetchReq::clear_include_context() {
  include_context_ = true;
  clear_has_include_context();
}
inline bool DtFetchReq::include_context() const {
  // @@protoc_insertion_point(field_get:DtFetchReq.include_context)
  return include_context_;
}
inline void DtFetchReq::set_include_context(bool value) {
  set_has_include_context();
  include_context_ = value;
  // @@protoc_insertion_point(field_set:DtFetchReq.include_context)
}

// -------------------------------------------------------------------

// DtValue

// optional sint64 counter_value = 1;
inline bool DtValue::has_counter_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtValue::set_has_counter_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtValue::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtValue::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 DtValue::counter_value() const {
  // @@protoc_insertion_point(field_get:DtValue.counter_value)
  return counter_value_;
}
inline void DtValue::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:DtValue.counter_value)
}

// repeated bytes set_value = 2;
inline int DtValue::set_value_size() const {
  return set_value_.size();
}
inline void DtValue::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& DtValue::set_value(int index) const {
  // @@protoc_insertion_point(field_get:DtValue.set_value)
  return set_value_.Get(index);
}
inline ::std::string* DtValue::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtValue.set_value)
  return set_value_.Mutable(index);
}
inline void DtValue::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DtValue.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void DtValue::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DtValue.set_value)
}
inline void DtValue::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtValue.set_value)
}
inline ::std::string* DtValue::add_set_value() {
  return set_value_.Add();
}
inline void DtValue::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DtValue.set_value)
}
inline void DtValue::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DtValue.set_value)
}
inline void DtValue::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DtValue.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DtValue::set_value() const {
  // @@protoc_insertion_point(field_list:DtValue.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DtValue::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:DtValue.set_value)
  return &set_value_;
}

// repeated .MapEntry map_value = 3;
inline int DtValue::map_value_size() const {
  return map_value_.size();
}
inline void DtValue::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& DtValue::map_value(int index) const {
  // @@protoc_insertion_point(field_get:DtValue.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* DtValue::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtValue.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* DtValue::add_map_value() {
  // @@protoc_insertion_point(field_add:DtValue.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
DtValue::map_value() const {
  // @@protoc_insertion_point(field_list:DtValue.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
DtValue::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:DtValue.map_value)
  return &map_value_;
}

// -------------------------------------------------------------------

// DtFetchResp

// optional bytes context = 1;
inline bool DtFetchResp::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtFetchResp::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtFetchResp::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtFetchResp::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtFetchResp::context() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.context)
  return *context_;
}
inline void DtFetchResp::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtFetchResp.context)
}
inline void DtFetchResp::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtFetchResp.context)
}
inline void DtFetchResp::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtFetchResp.context)
}
inline ::std::string* DtFetchResp::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtFetchResp.context)
  return context_;
}
inline ::std::string* DtFetchResp::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtFetchResp::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchResp.context)
}

// required .DtFetchResp.DataType type = 2;
inline bool DtFetchResp::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtFetchResp::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtFetchResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtFetchResp::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::DtFetchResp_DataType DtFetchResp::type() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.type)
  return static_cast< ::DtFetchResp_DataType >(type_);
}
inline void DtFetchResp::set_type(::DtFetchResp_DataType value) {
  assert(::DtFetchResp_DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DtFetchResp.type)
}

// optional .DtValue value = 3;
inline bool DtFetchResp::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtFetchResp::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtFetchResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtFetchResp::clear_value() {
  if (value_ != NULL) value_->::DtValue::Clear();
  clear_has_value();
}
inline const ::DtValue& DtFetchResp::value() const {
  // @@protoc_insertion_point(field_get:DtFetchResp.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::DtValue* DtFetchResp::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::DtValue;
  // @@protoc_insertion_point(field_mutable:DtFetchResp.value)
  return value_;
}
inline ::DtValue* DtFetchResp::release_value() {
  clear_has_value();
  ::DtValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void DtFetchResp::set_allocated_value(::DtValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:DtFetchResp.value)
}

// -------------------------------------------------------------------

// CounterOp

// optional sint64 increment = 1;
inline bool CounterOp::has_increment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CounterOp::set_has_increment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CounterOp::clear_has_increment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CounterOp::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
inline ::google::protobuf::int64 CounterOp::increment() const {
  // @@protoc_insertion_point(field_get:CounterOp.increment)
  return increment_;
}
inline void CounterOp::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:CounterOp.increment)
}

// -------------------------------------------------------------------

// SetOp

// repeated bytes adds = 1;
inline int SetOp::adds_size() const {
  return adds_.size();
}
inline void SetOp::clear_adds() {
  adds_.Clear();
}
inline const ::std::string& SetOp::adds(int index) const {
  // @@protoc_insertion_point(field_get:SetOp.adds)
  return adds_.Get(index);
}
inline ::std::string* SetOp::mutable_adds(int index) {
  // @@protoc_insertion_point(field_mutable:SetOp.adds)
  return adds_.Mutable(index);
}
inline void SetOp::set_adds(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SetOp.adds)
  adds_.Mutable(index)->assign(value);
}
inline void SetOp::set_adds(int index, const char* value) {
  adds_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOp.adds)
}
inline void SetOp::set_adds(int index, const void* value, size_t size) {
  adds_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOp.adds)
}
inline ::std::string* SetOp::add_adds() {
  return adds_.Add();
}
inline void SetOp::add_adds(const ::std::string& value) {
  adds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetOp.adds)
}
inline void SetOp::add_adds(const char* value) {
  adds_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetOp.adds)
}
inline void SetOp::add_adds(const void* value, size_t size) {
  adds_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetOp.adds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetOp::adds() const {
  // @@protoc_insertion_point(field_list:SetOp.adds)
  return adds_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetOp::mutable_adds() {
  // @@protoc_insertion_point(field_mutable_list:SetOp.adds)
  return &adds_;
}

// repeated bytes removes = 2;
inline int SetOp::removes_size() const {
  return removes_.size();
}
inline void SetOp::clear_removes() {
  removes_.Clear();
}
inline const ::std::string& SetOp::removes(int index) const {
  // @@protoc_insertion_point(field_get:SetOp.removes)
  return removes_.Get(index);
}
inline ::std::string* SetOp::mutable_removes(int index) {
  // @@protoc_insertion_point(field_mutable:SetOp.removes)
  return removes_.Mutable(index);
}
inline void SetOp::set_removes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SetOp.removes)
  removes_.Mutable(index)->assign(value);
}
inline void SetOp::set_removes(int index, const char* value) {
  removes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOp.removes)
}
inline void SetOp::set_removes(int index, const void* value, size_t size) {
  removes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOp.removes)
}
inline ::std::string* SetOp::add_removes() {
  return removes_.Add();
}
inline void SetOp::add_removes(const ::std::string& value) {
  removes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetOp.removes)
}
inline void SetOp::add_removes(const char* value) {
  removes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetOp.removes)
}
inline void SetOp::add_removes(const void* value, size_t size) {
  removes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetOp.removes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetOp::removes() const {
  // @@protoc_insertion_point(field_list:SetOp.removes)
  return removes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetOp::mutable_removes() {
  // @@protoc_insertion_point(field_mutable_list:SetOp.removes)
  return &removes_;
}

// -------------------------------------------------------------------

// MapUpdate

// required .MapField field = 1;
inline bool MapUpdate::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapUpdate::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapUpdate::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapUpdate::clear_field() {
  if (field_ != NULL) field_->::MapField::Clear();
  clear_has_field();
}
inline const ::MapField& MapUpdate::field() const {
  // @@protoc_insertion_point(field_get:MapUpdate.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::MapField* MapUpdate::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::MapField;
  // @@protoc_insertion_point(field_mutable:MapUpdate.field)
  return field_;
}
inline ::MapField* MapUpdate::release_field() {
  clear_has_field();
  ::MapField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_field(::MapField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.field)
}

// optional .CounterOp counter_op = 2;
inline bool MapUpdate::has_counter_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapUpdate::set_has_counter_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapUpdate::clear_has_counter_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapUpdate::clear_counter_op() {
  if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
  clear_has_counter_op();
}
inline const ::CounterOp& MapUpdate::counter_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.counter_op)
  return counter_op_ != NULL ? *counter_op_ : *default_instance_->counter_op_;
}
inline ::CounterOp* MapUpdate::mutable_counter_op() {
  set_has_counter_op();
  if (counter_op_ == NULL) counter_op_ = new ::CounterOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.counter_op)
  return counter_op_;
}
inline ::CounterOp* MapUpdate::release_counter_op() {
  clear_has_counter_op();
  ::CounterOp* temp = counter_op_;
  counter_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_counter_op(::CounterOp* counter_op) {
  delete counter_op_;
  counter_op_ = counter_op;
  if (counter_op) {
    set_has_counter_op();
  } else {
    clear_has_counter_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.counter_op)
}

// optional .SetOp set_op = 3;
inline bool MapUpdate::has_set_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapUpdate::set_has_set_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapUpdate::clear_has_set_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapUpdate::clear_set_op() {
  if (set_op_ != NULL) set_op_->::SetOp::Clear();
  clear_has_set_op();
}
inline const ::SetOp& MapUpdate::set_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.set_op)
  return set_op_ != NULL ? *set_op_ : *default_instance_->set_op_;
}
inline ::SetOp* MapUpdate::mutable_set_op() {
  set_has_set_op();
  if (set_op_ == NULL) set_op_ = new ::SetOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.set_op)
  return set_op_;
}
inline ::SetOp* MapUpdate::release_set_op() {
  clear_has_set_op();
  ::SetOp* temp = set_op_;
  set_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_set_op(::SetOp* set_op) {
  delete set_op_;
  set_op_ = set_op;
  if (set_op) {
    set_has_set_op();
  } else {
    clear_has_set_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.set_op)
}

// optional bytes register_op = 4;
inline bool MapUpdate::has_register_op() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapUpdate::set_has_register_op() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapUpdate::clear_has_register_op() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapUpdate::clear_register_op() {
  if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_->clear();
  }
  clear_has_register_op();
}
inline const ::std::string& MapUpdate::register_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.register_op)
  return *register_op_;
}
inline void MapUpdate::set_register_op(const ::std::string& value) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(value);
  // @@protoc_insertion_point(field_set:MapUpdate.register_op)
}
inline void MapUpdate::set_register_op(const char* value) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapUpdate.register_op)
}
inline void MapUpdate::set_register_op(const void* value, size_t size) {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  register_op_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapUpdate.register_op)
}
inline ::std::string* MapUpdate::mutable_register_op() {
  set_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    register_op_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapUpdate.register_op)
  return register_op_;
}
inline ::std::string* MapUpdate::release_register_op() {
  clear_has_register_op();
  if (register_op_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = register_op_;
    register_op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapUpdate::set_allocated_register_op(::std::string* register_op) {
  if (register_op_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete register_op_;
  }
  if (register_op) {
    set_has_register_op();
    register_op_ = register_op;
  } else {
    clear_has_register_op();
    register_op_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.register_op)
}

// optional .MapUpdate.FlagOp flag_op = 5;
inline bool MapUpdate::has_flag_op() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapUpdate::set_has_flag_op() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapUpdate::clear_has_flag_op() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapUpdate::clear_flag_op() {
  flag_op_ = 1;
  clear_has_flag_op();
}
inline ::MapUpdate_FlagOp MapUpdate::flag_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.flag_op)
  return static_cast< ::MapUpdate_FlagOp >(flag_op_);
}
inline void MapUpdate::set_flag_op(::MapUpdate_FlagOp value) {
  assert(::MapUpdate_FlagOp_IsValid(value));
  set_has_flag_op();
  flag_op_ = value;
  // @@protoc_insertion_point(field_set:MapUpdate.flag_op)
}

// optional .MapOp map_op = 6;
inline bool MapUpdate::has_map_op() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapUpdate::set_has_map_op() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapUpdate::clear_has_map_op() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapUpdate::clear_map_op() {
  if (map_op_ != NULL) map_op_->::MapOp::Clear();
  clear_has_map_op();
}
inline const ::MapOp& MapUpdate::map_op() const {
  // @@protoc_insertion_point(field_get:MapUpdate.map_op)
  return map_op_ != NULL ? *map_op_ : *default_instance_->map_op_;
}
inline ::MapOp* MapUpdate::mutable_map_op() {
  set_has_map_op();
  if (map_op_ == NULL) map_op_ = new ::MapOp;
  // @@protoc_insertion_point(field_mutable:MapUpdate.map_op)
  return map_op_;
}
inline ::MapOp* MapUpdate::release_map_op() {
  clear_has_map_op();
  ::MapOp* temp = map_op_;
  map_op_ = NULL;
  return temp;
}
inline void MapUpdate::set_allocated_map_op(::MapOp* map_op) {
  delete map_op_;
  map_op_ = map_op;
  if (map_op) {
    set_has_map_op();
  } else {
    clear_has_map_op();
  }
  // @@protoc_insertion_point(field_set_allocated:MapUpdate.map_op)
}

// -------------------------------------------------------------------

// MapOp

// repeated .MapField removes = 1;
inline int MapOp::removes_size() const {
  return removes_.size();
}
inline void MapOp::clear_removes() {
  removes_.Clear();
}
inline const ::MapField& MapOp::removes(int index) const {
  // @@protoc_insertion_point(field_get:MapOp.removes)
  return removes_.Get(index);
}
inline ::MapField* MapOp::mutable_removes(int index) {
  // @@protoc_insertion_point(field_mutable:MapOp.removes)
  return removes_.Mutable(index);
}
inline ::MapField* MapOp::add_removes() {
  // @@protoc_insertion_point(field_add:MapOp.removes)
  return removes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapField >&
MapOp::removes() const {
  // @@protoc_insertion_point(field_list:MapOp.removes)
  return removes_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapField >*
MapOp::mutable_removes() {
  // @@protoc_insertion_point(field_mutable_list:MapOp.removes)
  return &removes_;
}

// repeated .MapUpdate updates = 2;
inline int MapOp::updates_size() const {
  return updates_.size();
}
inline void MapOp::clear_updates() {
  updates_.Clear();
}
inline const ::MapUpdate& MapOp::updates(int index) const {
  // @@protoc_insertion_point(field_get:MapOp.updates)
  return updates_.Get(index);
}
inline ::MapUpdate* MapOp::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:MapOp.updates)
  return updates_.Mutable(index);
}
inline ::MapUpdate* MapOp::add_updates() {
  // @@protoc_insertion_point(field_add:MapOp.updates)
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapUpdate >&
MapOp::updates() const {
  // @@protoc_insertion_point(field_list:MapOp.updates)
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapUpdate >*
MapOp::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:MapOp.updates)
  return &updates_;
}

// -------------------------------------------------------------------

// DtOp

// optional .CounterOp counter_op = 1;
inline bool DtOp::has_counter_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtOp::set_has_counter_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtOp::clear_has_counter_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtOp::clear_counter_op() {
  if (counter_op_ != NULL) counter_op_->::CounterOp::Clear();
  clear_has_counter_op();
}
inline const ::CounterOp& DtOp::counter_op() const {
  // @@protoc_insertion_point(field_get:DtOp.counter_op)
  return counter_op_ != NULL ? *counter_op_ : *default_instance_->counter_op_;
}
inline ::CounterOp* DtOp::mutable_counter_op() {
  set_has_counter_op();
  if (counter_op_ == NULL) counter_op_ = new ::CounterOp;
  // @@protoc_insertion_point(field_mutable:DtOp.counter_op)
  return counter_op_;
}
inline ::CounterOp* DtOp::release_counter_op() {
  clear_has_counter_op();
  ::CounterOp* temp = counter_op_;
  counter_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_counter_op(::CounterOp* counter_op) {
  delete counter_op_;
  counter_op_ = counter_op;
  if (counter_op) {
    set_has_counter_op();
  } else {
    clear_has_counter_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.counter_op)
}

// optional .SetOp set_op = 2;
inline bool DtOp::has_set_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtOp::set_has_set_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtOp::clear_has_set_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtOp::clear_set_op() {
  if (set_op_ != NULL) set_op_->::SetOp::Clear();
  clear_has_set_op();
}
inline const ::SetOp& DtOp::set_op() const {
  // @@protoc_insertion_point(field_get:DtOp.set_op)
  return set_op_ != NULL ? *set_op_ : *default_instance_->set_op_;
}
inline ::SetOp* DtOp::mutable_set_op() {
  set_has_set_op();
  if (set_op_ == NULL) set_op_ = new ::SetOp;
  // @@protoc_insertion_point(field_mutable:DtOp.set_op)
  return set_op_;
}
inline ::SetOp* DtOp::release_set_op() {
  clear_has_set_op();
  ::SetOp* temp = set_op_;
  set_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_set_op(::SetOp* set_op) {
  delete set_op_;
  set_op_ = set_op;
  if (set_op) {
    set_has_set_op();
  } else {
    clear_has_set_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.set_op)
}

// optional .MapOp map_op = 3;
inline bool DtOp::has_map_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtOp::set_has_map_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtOp::clear_has_map_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtOp::clear_map_op() {
  if (map_op_ != NULL) map_op_->::MapOp::Clear();
  clear_has_map_op();
}
inline const ::MapOp& DtOp::map_op() const {
  // @@protoc_insertion_point(field_get:DtOp.map_op)
  return map_op_ != NULL ? *map_op_ : *default_instance_->map_op_;
}
inline ::MapOp* DtOp::mutable_map_op() {
  set_has_map_op();
  if (map_op_ == NULL) map_op_ = new ::MapOp;
  // @@protoc_insertion_point(field_mutable:DtOp.map_op)
  return map_op_;
}
inline ::MapOp* DtOp::release_map_op() {
  clear_has_map_op();
  ::MapOp* temp = map_op_;
  map_op_ = NULL;
  return temp;
}
inline void DtOp::set_allocated_map_op(::MapOp* map_op) {
  delete map_op_;
  map_op_ = map_op;
  if (map_op) {
    set_has_map_op();
  } else {
    clear_has_map_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtOp.map_op)
}

// -------------------------------------------------------------------

// DtUpdateReq

// required bytes bucket = 1;
inline bool DtUpdateReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtUpdateReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtUpdateReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtUpdateReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& DtUpdateReq::bucket() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.bucket)
  return *bucket_;
}
inline void DtUpdateReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.bucket)
}
inline void DtUpdateReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.bucket)
}
inline void DtUpdateReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.bucket)
}
inline ::std::string* DtUpdateReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.bucket)
  return bucket_;
}
inline ::std::string* DtUpdateReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.bucket)
}

// optional bytes key = 2;
inline bool DtUpdateReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtUpdateReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtUpdateReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtUpdateReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtUpdateReq::key() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.key)
  return *key_;
}
inline void DtUpdateReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.key)
}
inline void DtUpdateReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.key)
}
inline void DtUpdateReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.key)
}
inline ::std::string* DtUpdateReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.key)
  return key_;
}
inline ::std::string* DtUpdateReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.key)
}

// required bytes type = 3;
inline bool DtUpdateReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtUpdateReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtUpdateReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtUpdateReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DtUpdateReq::type() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.type)
  return *type_;
}
inline void DtUpdateReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.type)
}
inline void DtUpdateReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.type)
}
inline void DtUpdateReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.type)
}
inline ::std::string* DtUpdateReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.type)
  return type_;
}
inline ::std::string* DtUpdateReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.type)
}

// optional bytes context = 4;
inline bool DtUpdateReq::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DtUpdateReq::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DtUpdateReq::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DtUpdateReq::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtUpdateReq::context() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.context)
  return *context_;
}
inline void DtUpdateReq::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateReq.context)
}
inline void DtUpdateReq::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateReq.context)
}
inline void DtUpdateReq::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateReq.context)
}
inline ::std::string* DtUpdateReq::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.context)
  return context_;
}
inline ::std::string* DtUpdateReq::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateReq::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.context)
}

// required .DtOp op = 5;
inline bool DtUpdateReq::has_op() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DtUpdateReq::set_has_op() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DtUpdateReq::clear_has_op() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DtUpdateReq::clear_op() {
  if (op_ != NULL) op_->::DtOp::Clear();
  clear_has_op();
}
inline const ::DtOp& DtUpdateReq::op() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.op)
  return op_ != NULL ? *op_ : *default_instance_->op_;
}
inline ::DtOp* DtUpdateReq::mutable_op() {
  set_has_op();
  if (op_ == NULL) op_ = new ::DtOp;
  // @@protoc_insertion_point(field_mutable:DtUpdateReq.op)
  return op_;
}
inline ::DtOp* DtUpdateReq::release_op() {
  clear_has_op();
  ::DtOp* temp = op_;
  op_ = NULL;
  return temp;
}
inline void DtUpdateReq::set_allocated_op(::DtOp* op) {
  delete op_;
  op_ = op;
  if (op) {
    set_has_op();
  } else {
    clear_has_op();
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateReq.op)
}

// optional uint32 w = 6;
inline bool DtUpdateReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DtUpdateReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DtUpdateReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DtUpdateReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 DtUpdateReq::w() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.w)
  return w_;
}
inline void DtUpdateReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.w)
}

// optional uint32 dw = 7;
inline bool DtUpdateReq::has_dw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DtUpdateReq::set_has_dw() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DtUpdateReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DtUpdateReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 DtUpdateReq::dw() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.dw)
  return dw_;
}
inline void DtUpdateReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.dw)
}

// optional uint32 pw = 8;
inline bool DtUpdateReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DtUpdateReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DtUpdateReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DtUpdateReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 DtUpdateReq::pw() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.pw)
  return pw_;
}
inline void DtUpdateReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.pw)
}

// optional bool return_body = 9 [default = false];
inline bool DtUpdateReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DtUpdateReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DtUpdateReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DtUpdateReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool DtUpdateReq::return_body() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.return_body)
  return return_body_;
}
inline void DtUpdateReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.return_body)
}

// optional uint32 timeout = 10;
inline bool DtUpdateReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DtUpdateReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DtUpdateReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DtUpdateReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 DtUpdateReq::timeout() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.timeout)
  return timeout_;
}
inline void DtUpdateReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool DtUpdateReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DtUpdateReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DtUpdateReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DtUpdateReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool DtUpdateReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void DtUpdateReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool DtUpdateReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DtUpdateReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DtUpdateReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DtUpdateReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 DtUpdateReq::n_val() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.n_val)
  return n_val_;
}
inline void DtUpdateReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.n_val)
}

// optional bool include_context = 13 [default = true];
inline bool DtUpdateReq::has_include_context() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DtUpdateReq::set_has_include_context() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DtUpdateReq::clear_has_include_context() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DtUpdateReq::clear_include_context() {
  include_context_ = true;
  clear_has_include_context();
}
inline bool DtUpdateReq::include_context() const {
  // @@protoc_insertion_point(field_get:DtUpdateReq.include_context)
  return include_context_;
}
inline void DtUpdateReq::set_include_context(bool value) {
  set_has_include_context();
  include_context_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateReq.include_context)
}

// -------------------------------------------------------------------

// DtUpdateResp

// optional bytes key = 1;
inline bool DtUpdateResp::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DtUpdateResp::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DtUpdateResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DtUpdateResp::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DtUpdateResp::key() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.key)
  return *key_;
}
inline void DtUpdateResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateResp.key)
}
inline void DtUpdateResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.key)
}
inline void DtUpdateResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.key)
}
inline ::std::string* DtUpdateResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.key)
  return key_;
}
inline ::std::string* DtUpdateResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateResp::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateResp.key)
}

// optional bytes context = 2;
inline bool DtUpdateResp::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DtUpdateResp::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DtUpdateResp::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DtUpdateResp::clear_context() {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_->clear();
  }
  clear_has_context();
}
inline const ::std::string& DtUpdateResp::context() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.context)
  return *context_;
}
inline void DtUpdateResp::set_context(const ::std::string& value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set:DtUpdateResp.context)
}
inline void DtUpdateResp::set_context(const char* value) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.context)
}
inline void DtUpdateResp::set_context(const void* value, size_t size) {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.context)
}
inline ::std::string* DtUpdateResp::mutable_context() {
  set_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.context)
  return context_;
}
inline ::std::string* DtUpdateResp::release_context() {
  clear_has_context();
  if (context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = context_;
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DtUpdateResp::set_allocated_context(::std::string* context) {
  if (context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete context_;
  }
  if (context) {
    set_has_context();
    context_ = context;
  } else {
    clear_has_context();
    context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DtUpdateResp.context)
}

// optional sint64 counter_value = 3;
inline bool DtUpdateResp::has_counter_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DtUpdateResp::set_has_counter_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DtUpdateResp::clear_has_counter_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DtUpdateResp::clear_counter_value() {
  counter_value_ = GOOGLE_LONGLONG(0);
  clear_has_counter_value();
}
inline ::google::protobuf::int64 DtUpdateResp::counter_value() const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.counter_value)
  return counter_value_;
}
inline void DtUpdateResp::set_counter_value(::google::protobuf::int64 value) {
  set_has_counter_value();
  counter_value_ = value;
  // @@protoc_insertion_point(field_set:DtUpdateResp.counter_value)
}

// repeated bytes set_value = 4;
inline int DtUpdateResp::set_value_size() const {
  return set_value_.size();
}
inline void DtUpdateResp::clear_set_value() {
  set_value_.Clear();
}
inline const ::std::string& DtUpdateResp::set_value(int index) const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.set_value)
  return set_value_.Get(index);
}
inline ::std::string* DtUpdateResp::mutable_set_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.set_value)
  return set_value_.Mutable(index);
}
inline void DtUpdateResp::set_set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DtUpdateResp.set_value)
  set_value_.Mutable(index)->assign(value);
}
inline void DtUpdateResp::set_set_value(int index, const char* value) {
  set_value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DtUpdateResp.set_value)
}
inline void DtUpdateResp::set_set_value(int index, const void* value, size_t size) {
  set_value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DtUpdateResp.set_value)
}
inline ::std::string* DtUpdateResp::add_set_value() {
  return set_value_.Add();
}
inline void DtUpdateResp::add_set_value(const ::std::string& value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DtUpdateResp.set_value)
}
inline void DtUpdateResp::add_set_value(const char* value) {
  set_value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DtUpdateResp.set_value)
}
inline void DtUpdateResp::add_set_value(const void* value, size_t size) {
  set_value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DtUpdateResp.set_value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DtUpdateResp::set_value() const {
  // @@protoc_insertion_point(field_list:DtUpdateResp.set_value)
  return set_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DtUpdateResp::mutable_set_value() {
  // @@protoc_insertion_point(field_mutable_list:DtUpdateResp.set_value)
  return &set_value_;
}

// repeated .MapEntry map_value = 5;
inline int DtUpdateResp::map_value_size() const {
  return map_value_.size();
}
inline void DtUpdateResp::clear_map_value() {
  map_value_.Clear();
}
inline const ::MapEntry& DtUpdateResp::map_value(int index) const {
  // @@protoc_insertion_point(field_get:DtUpdateResp.map_value)
  return map_value_.Get(index);
}
inline ::MapEntry* DtUpdateResp::mutable_map_value(int index) {
  // @@protoc_insertion_point(field_mutable:DtUpdateResp.map_value)
  return map_value_.Mutable(index);
}
inline ::MapEntry* DtUpdateResp::add_map_value() {
  // @@protoc_insertion_point(field_add:DtUpdateResp.map_value)
  return map_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapEntry >&
DtUpdateResp::map_value() const {
  // @@protoc_insertion_point(field_list:DtUpdateResp.map_value)
  return map_value_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapEntry >*
DtUpdateResp::mutable_map_value() {
  // @@protoc_insertion_point(field_mutable_list:DtUpdateResp.map_value)
  return &map_value_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MapField_MapFieldType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapField_MapFieldType>() {
  return ::MapField_MapFieldType_descriptor();
}
template <> struct is_proto_enum< ::DtFetchResp_DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DtFetchResp_DataType>() {
  return ::DtFetchResp_DataType_descriptor();
}
template <> struct is_proto_enum< ::MapUpdate_FlagOp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MapUpdate_FlagOp>() {
  return ::MapUpdate_FlagOp_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_5fdt_2eproto__INCLUDED
