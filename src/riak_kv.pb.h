// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riak_kv.proto

#ifndef PROTOBUF_riak_5fkv_2eproto__INCLUDED
#define PROTOBUF_riak_5fkv_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "riak.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_riak_5fkv_2eproto();
void protobuf_AssignDesc_riak_5fkv_2eproto();
void protobuf_ShutdownFile_riak_5fkv_2eproto();

class RpbGetClientIdResp;
class RpbSetClientIdReq;
class RpbGetReq;
class RpbGetResp;
class RpbPutReq;
class RpbPutResp;
class RpbDelReq;
class RpbListBucketsReq;
class RpbListBucketsResp;
class RpbListKeysReq;
class RpbListKeysResp;
class RpbMapRedReq;
class RpbMapRedResp;
class RpbIndexReq;
class RpbIndexResp;
class RpbIndexBodyResp;
class RpbCSBucketReq;
class RpbCSBucketResp;
class RpbIndexObject;
class RpbContent;
class RpbLink;
class RpbCounterUpdateReq;
class RpbCounterUpdateResp;
class RpbCounterGetReq;
class RpbCounterGetResp;
class RpbGetBucketKeyPreflistReq;
class RpbGetBucketKeyPreflistResp;
class RpbBucketKeyPreflistItem;
class RpbCoverageReq;
class RpbCoverageResp;
class RpbCoverageEntry;

enum RpbIndexReq_IndexQueryType {
  RpbIndexReq_IndexQueryType_eq = 0,
  RpbIndexReq_IndexQueryType_range = 1
};
bool RpbIndexReq_IndexQueryType_IsValid(int value);
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MIN = RpbIndexReq_IndexQueryType_eq;
const RpbIndexReq_IndexQueryType RpbIndexReq_IndexQueryType_IndexQueryType_MAX = RpbIndexReq_IndexQueryType_range;
const int RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE = RpbIndexReq_IndexQueryType_IndexQueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpbIndexReq_IndexQueryType_descriptor();
inline const ::std::string& RpbIndexReq_IndexQueryType_Name(RpbIndexReq_IndexQueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpbIndexReq_IndexQueryType_descriptor(), value);
}
inline bool RpbIndexReq_IndexQueryType_Parse(
    const ::std::string& name, RpbIndexReq_IndexQueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpbIndexReq_IndexQueryType>(
    RpbIndexReq_IndexQueryType_descriptor(), name, value);
}
// ===================================================================

class RpbGetClientIdResp : public ::google::protobuf::Message {
 public:
  RpbGetClientIdResp();
  virtual ~RpbGetClientIdResp();

  RpbGetClientIdResp(const RpbGetClientIdResp& from);

  inline RpbGetClientIdResp& operator=(const RpbGetClientIdResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetClientIdResp& default_instance();

  void Swap(RpbGetClientIdResp* other);

  // implements Message ----------------------------------------------

  RpbGetClientIdResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetClientIdResp& from);
  void MergeFrom(const RpbGetClientIdResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:RpbGetClientIdResp)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbGetClientIdResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbSetClientIdReq : public ::google::protobuf::Message {
 public:
  RpbSetClientIdReq();
  virtual ~RpbSetClientIdReq();

  RpbSetClientIdReq(const RpbSetClientIdReq& from);

  inline RpbSetClientIdReq& operator=(const RpbSetClientIdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbSetClientIdReq& default_instance();

  void Swap(RpbSetClientIdReq* other);

  // implements Message ----------------------------------------------

  RpbSetClientIdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbSetClientIdReq& from);
  void MergeFrom(const RpbSetClientIdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const void* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:RpbSetClientIdReq)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbSetClientIdReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetReq : public ::google::protobuf::Message {
 public:
  RpbGetReq();
  virtual ~RpbGetReq();

  RpbGetReq(const RpbGetReq& from);

  inline RpbGetReq& operator=(const RpbGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetReq& default_instance();

  void Swap(RpbGetReq* other);

  // implements Message ----------------------------------------------

  RpbGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetReq& from);
  void MergeFrom(const RpbGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // optional bytes if_modified = 7;
  inline bool has_if_modified() const;
  inline void clear_if_modified();
  static const int kIfModifiedFieldNumber = 7;
  inline const ::std::string& if_modified() const;
  inline void set_if_modified(const ::std::string& value);
  inline void set_if_modified(const char* value);
  inline void set_if_modified(const void* value, size_t size);
  inline ::std::string* mutable_if_modified();
  inline ::std::string* release_if_modified();
  inline void set_allocated_if_modified(::std::string* if_modified);

  // optional bool head = 8;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 8;
  inline bool head() const;
  inline void set_head(bool value);

  // optional bool deletedvclock = 9;
  inline bool has_deletedvclock() const;
  inline void clear_deletedvclock();
  static const int kDeletedvclockFieldNumber = 9;
  inline bool deletedvclock() const;
  inline void set_deletedvclock(bool value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();
  inline void set_has_if_modified();
  inline void clear_has_if_modified();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_deletedvclock();
  inline void clear_has_deletedvclock();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  ::std::string* if_modified_;
  bool basic_quorum_;
  bool notfound_ok_;
  bool head_;
  bool deletedvclock_;
  ::google::protobuf::uint32 timeout_;
  bool sloppy_quorum_;
  ::google::protobuf::uint32 n_val_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetResp : public ::google::protobuf::Message {
 public:
  RpbGetResp();
  virtual ~RpbGetResp();

  RpbGetResp(const RpbGetResp& from);

  inline RpbGetResp& operator=(const RpbGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetResp& default_instance();

  void Swap(RpbGetResp* other);

  // implements Message ----------------------------------------------

  RpbGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetResp& from);
  void MergeFrom(const RpbGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional bool unchanged = 3;
  inline bool has_unchanged() const;
  inline void clear_unchanged();
  static const int kUnchangedFieldNumber = 3;
  inline bool unchanged() const;
  inline void set_unchanged(bool value);

  // @@protoc_insertion_point(class_scope:RpbGetResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_unchanged();
  inline void clear_has_unchanged();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  bool unchanged_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutReq : public ::google::protobuf::Message {
 public:
  RpbPutReq();
  virtual ~RpbPutReq();

  RpbPutReq(const RpbPutReq& from);

  inline RpbPutReq& operator=(const RpbPutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutReq& default_instance();

  void Swap(RpbPutReq* other);

  // implements Message ----------------------------------------------

  RpbPutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutReq& from);
  void MergeFrom(const RpbPutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes vclock = 3;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 3;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // required .RpbContent content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::RpbContent& content() const;
  inline ::RpbContent* mutable_content();
  inline ::RpbContent* release_content();
  inline void set_allocated_content(::RpbContent* content);

  // optional uint32 w = 5;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 5;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 6;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 6;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional bool return_body = 7;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 7;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool if_not_modified = 9;
  inline bool has_if_not_modified() const;
  inline void clear_if_not_modified();
  static const int kIfNotModifiedFieldNumber = 9;
  inline bool if_not_modified() const;
  inline void set_if_not_modified(bool value);

  // optional bool if_none_match = 10;
  inline bool has_if_none_match() const;
  inline void clear_if_none_match();
  static const int kIfNoneMatchFieldNumber = 10;
  inline bool if_none_match() const;
  inline void set_if_none_match(bool value);

  // optional bool return_head = 11;
  inline bool has_return_head() const;
  inline void clear_return_head();
  static const int kReturnHeadFieldNumber = 11;
  inline bool return_head() const;
  inline void set_return_head(bool value);

  // optional uint32 timeout = 12;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 12;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool asis = 13;
  inline bool has_asis() const;
  inline void clear_asis();
  static const int kAsisFieldNumber = 13;
  inline bool asis() const;
  inline void set_asis(bool value);

  // optional bool sloppy_quorum = 14;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 14;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 15;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 15;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 16;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 16;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbPutReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_return_body();
  inline void clear_has_return_body();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_if_not_modified();
  inline void clear_has_if_not_modified();
  inline void set_has_if_none_match();
  inline void clear_has_if_none_match();
  inline void set_has_return_head();
  inline void clear_has_return_head();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_asis();
  inline void clear_has_asis();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::RpbContent* content_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool return_body_;
  bool if_not_modified_;
  bool if_none_match_;
  bool return_head_;
  ::google::protobuf::uint32 timeout_;
  bool asis_;
  bool sloppy_quorum_;
  ::std::string* type_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbPutReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbPutResp : public ::google::protobuf::Message {
 public:
  RpbPutResp();
  virtual ~RpbPutResp();

  RpbPutResp(const RpbPutResp& from);

  inline RpbPutResp& operator=(const RpbPutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbPutResp& default_instance();

  void Swap(RpbPutResp* other);

  // implements Message ----------------------------------------------

  RpbPutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbPutResp& from);
  void MergeFrom(const RpbPutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbContent content = 1;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::RpbContent& content(int index) const;
  inline ::RpbContent* mutable_content(int index);
  inline ::RpbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
      mutable_content();

  // optional bytes vclock = 2;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 2;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:RpbPutResp)
 private:
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbContent > content_;
  ::std::string* vclock_;
  ::std::string* key_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbPutResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbDelReq : public ::google::protobuf::Message {
 public:
  RpbDelReq();
  virtual ~RpbDelReq();

  RpbDelReq(const RpbDelReq& from);

  inline RpbDelReq& operator=(const RpbDelReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbDelReq& default_instance();

  void Swap(RpbDelReq* other);

  // implements Message ----------------------------------------------

  RpbDelReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbDelReq& from);
  void MergeFrom(const RpbDelReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 rw = 3;
  inline bool has_rw() const;
  inline void clear_rw();
  static const int kRwFieldNumber = 3;
  inline ::google::protobuf::uint32 rw() const;
  inline void set_rw(::google::protobuf::uint32 value);

  // optional bytes vclock = 4;
  inline bool has_vclock() const;
  inline void clear_vclock();
  static const int kVclockFieldNumber = 4;
  inline const ::std::string& vclock() const;
  inline void set_vclock(const ::std::string& value);
  inline void set_vclock(const char* value);
  inline void set_vclock(const void* value, size_t size);
  inline ::std::string* mutable_vclock();
  inline ::std::string* release_vclock();
  inline void set_allocated_vclock(::std::string* vclock);

  // optional uint32 r = 5;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 5;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 w = 6;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 pr = 7;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 7;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional uint32 pw = 8;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 8;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional uint32 dw = 9;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 9;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 timeout = 10;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool sloppy_quorum = 11;
  inline bool has_sloppy_quorum() const;
  inline void clear_sloppy_quorum();
  static const int kSloppyQuorumFieldNumber = 11;
  inline bool sloppy_quorum() const;
  inline void set_sloppy_quorum(bool value);

  // optional uint32 n_val = 12;
  inline bool has_n_val() const;
  inline void clear_n_val();
  static const int kNValFieldNumber = 12;
  inline ::google::protobuf::uint32 n_val() const;
  inline void set_n_val(::google::protobuf::uint32 value);

  // optional bytes type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbDelReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_rw();
  inline void clear_has_rw();
  inline void set_has_vclock();
  inline void clear_has_vclock();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_sloppy_quorum();
  inline void clear_has_sloppy_quorum();
  inline void set_has_n_val();
  inline void clear_has_n_val();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* vclock_;
  ::google::protobuf::uint32 rw_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 pr_;
  ::google::protobuf::uint32 pw_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 timeout_;
  bool sloppy_quorum_;
  ::std::string* type_;
  ::google::protobuf::uint32 n_val_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbDelReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsReq : public ::google::protobuf::Message {
 public:
  RpbListBucketsReq();
  virtual ~RpbListBucketsReq();

  RpbListBucketsReq(const RpbListBucketsReq& from);

  inline RpbListBucketsReq& operator=(const RpbListBucketsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsReq& default_instance();

  void Swap(RpbListBucketsReq* other);

  // implements Message ----------------------------------------------

  RpbListBucketsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsReq& from);
  void MergeFrom(const RpbListBucketsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout = 1;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bool stream = 2;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 2;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbListBucketsReq)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_;
  bool stream_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbListBucketsReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListBucketsResp : public ::google::protobuf::Message {
 public:
  RpbListBucketsResp();
  virtual ~RpbListBucketsResp();

  RpbListBucketsResp(const RpbListBucketsResp& from);

  inline RpbListBucketsResp& operator=(const RpbListBucketsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListBucketsResp& default_instance();

  void Swap(RpbListBucketsResp* other);

  // implements Message ----------------------------------------------

  RpbListBucketsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListBucketsResp& from);
  void MergeFrom(const RpbListBucketsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes buckets = 1;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const void* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbListBucketsResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbListBucketsResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysReq : public ::google::protobuf::Message {
 public:
  RpbListKeysReq();
  virtual ~RpbListKeysReq();

  RpbListKeysReq(const RpbListKeysReq& from);

  inline RpbListKeysReq& operator=(const RpbListKeysReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysReq& default_instance();

  void Swap(RpbListKeysReq* other);

  // implements Message ----------------------------------------------

  RpbListKeysReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysReq& from);
  void MergeFrom(const RpbListKeysReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional uint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbListKeysReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* type_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbListKeysResp : public ::google::protobuf::Message {
 public:
  RpbListKeysResp();
  virtual ~RpbListKeysResp();

  RpbListKeysResp(const RpbListKeysResp& from);

  inline RpbListKeysResp& operator=(const RpbListKeysResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbListKeysResp& default_instance();

  void Swap(RpbListKeysResp* other);

  // implements Message ----------------------------------------------

  RpbListKeysResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbListKeysResp& from);
  void MergeFrom(const RpbListKeysResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bool done = 2;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 2;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbListKeysResp)
 private:
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbListKeysResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedReq : public ::google::protobuf::Message {
 public:
  RpbMapRedReq();
  virtual ~RpbMapRedReq();

  RpbMapRedReq(const RpbMapRedReq& from);

  inline RpbMapRedReq& operator=(const RpbMapRedReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedReq& default_instance();

  void Swap(RpbMapRedReq* other);

  // implements Message ----------------------------------------------

  RpbMapRedReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedReq& from);
  void MergeFrom(const RpbMapRedReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  inline void set_allocated_request(::std::string* request);

  // required bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // @@protoc_insertion_point(class_scope:RpbMapRedReq)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_content_type();
  inline void clear_has_content_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* request_;
  ::std::string* content_type_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbMapRedResp : public ::google::protobuf::Message {
 public:
  RpbMapRedResp();
  virtual ~RpbMapRedResp();

  RpbMapRedResp(const RpbMapRedResp& from);

  inline RpbMapRedResp& operator=(const RpbMapRedResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbMapRedResp& default_instance();

  void Swap(RpbMapRedResp* other);

  // implements Message ----------------------------------------------

  RpbMapRedResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbMapRedResp& from);
  void MergeFrom(const RpbMapRedResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 phase = 1;
  inline bool has_phase() const;
  inline void clear_phase();
  static const int kPhaseFieldNumber = 1;
  inline ::google::protobuf::uint32 phase() const;
  inline void set_phase(::google::protobuf::uint32 value);

  // optional bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  inline void set_allocated_response(::std::string* response);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbMapRedResp)
 private:
  inline void set_has_phase();
  inline void clear_has_phase();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* response_;
  ::google::protobuf::uint32 phase_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbMapRedResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexReq : public ::google::protobuf::Message {
 public:
  RpbIndexReq();
  virtual ~RpbIndexReq();

  RpbIndexReq(const RpbIndexReq& from);

  inline RpbIndexReq& operator=(const RpbIndexReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexReq& default_instance();

  void Swap(RpbIndexReq* other);

  // implements Message ----------------------------------------------

  RpbIndexReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexReq& from);
  void MergeFrom(const RpbIndexReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpbIndexReq_IndexQueryType IndexQueryType;
  static const IndexQueryType eq = RpbIndexReq_IndexQueryType_eq;
  static const IndexQueryType range = RpbIndexReq_IndexQueryType_range;
  static inline bool IndexQueryType_IsValid(int value) {
    return RpbIndexReq_IndexQueryType_IsValid(value);
  }
  static const IndexQueryType IndexQueryType_MIN =
    RpbIndexReq_IndexQueryType_IndexQueryType_MIN;
  static const IndexQueryType IndexQueryType_MAX =
    RpbIndexReq_IndexQueryType_IndexQueryType_MAX;
  static const int IndexQueryType_ARRAYSIZE =
    RpbIndexReq_IndexQueryType_IndexQueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IndexQueryType_descriptor() {
    return RpbIndexReq_IndexQueryType_descriptor();
  }
  static inline const ::std::string& IndexQueryType_Name(IndexQueryType value) {
    return RpbIndexReq_IndexQueryType_Name(value);
  }
  static inline bool IndexQueryType_Parse(const ::std::string& name,
      IndexQueryType* value) {
    return RpbIndexReq_IndexQueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  inline ::std::string* release_index();
  inline void set_allocated_index(::std::string* index);

  // required .RpbIndexReq.IndexQueryType qtype = 3;
  inline bool has_qtype() const;
  inline void clear_qtype();
  static const int kQtypeFieldNumber = 3;
  inline ::RpbIndexReq_IndexQueryType qtype() const;
  inline void set_qtype(::RpbIndexReq_IndexQueryType value);

  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes range_min = 5;
  inline bool has_range_min() const;
  inline void clear_range_min();
  static const int kRangeMinFieldNumber = 5;
  inline const ::std::string& range_min() const;
  inline void set_range_min(const ::std::string& value);
  inline void set_range_min(const char* value);
  inline void set_range_min(const void* value, size_t size);
  inline ::std::string* mutable_range_min();
  inline ::std::string* release_range_min();
  inline void set_allocated_range_min(::std::string* range_min);

  // optional bytes range_max = 6;
  inline bool has_range_max() const;
  inline void clear_range_max();
  static const int kRangeMaxFieldNumber = 6;
  inline const ::std::string& range_max() const;
  inline void set_range_max(const ::std::string& value);
  inline void set_range_max(const char* value);
  inline void set_range_max(const void* value, size_t size);
  inline ::std::string* mutable_range_max();
  inline ::std::string* release_range_max();
  inline void set_allocated_range_max(::std::string* range_max);

  // optional bool return_terms = 7;
  inline bool has_return_terms() const;
  inline void clear_return_terms();
  static const int kReturnTermsFieldNumber = 7;
  inline bool return_terms() const;
  inline void set_return_terms(bool value);

  // optional bool stream = 8;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 8;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional uint32 max_results = 9;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 9;
  inline ::google::protobuf::uint32 max_results() const;
  inline void set_max_results(::google::protobuf::uint32 value);

  // optional bytes continuation = 10;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 10;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional uint32 timeout = 11;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 11;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 12;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 12;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes term_regex = 13;
  inline bool has_term_regex() const;
  inline void clear_term_regex();
  static const int kTermRegexFieldNumber = 13;
  inline const ::std::string& term_regex() const;
  inline void set_term_regex(const ::std::string& value);
  inline void set_term_regex(const char* value);
  inline void set_term_regex(const void* value, size_t size);
  inline ::std::string* mutable_term_regex();
  inline ::std::string* release_term_regex();
  inline void set_allocated_term_regex(::std::string* term_regex);

  // optional bool pagination_sort = 14;
  inline bool has_pagination_sort() const;
  inline void clear_pagination_sort();
  static const int kPaginationSortFieldNumber = 14;
  inline bool pagination_sort() const;
  inline void set_pagination_sort(bool value);

  // optional bytes cover_context = 15;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 15;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // optional bool return_body = 16;
  inline bool has_return_body() const;
  inline void clear_return_body();
  static const int kReturnBodyFieldNumber = 16;
  inline bool return_body() const;
  inline void set_return_body(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_qtype();
  inline void clear_has_qtype();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_range_min();
  inline void clear_has_range_min();
  inline void set_has_range_max();
  inline void clear_has_range_max();
  inline void set_has_return_terms();
  inline void clear_has_return_terms();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_max_results();
  inline void clear_has_max_results();
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_term_regex();
  inline void clear_has_term_regex();
  inline void set_has_pagination_sort();
  inline void clear_has_pagination_sort();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();
  inline void set_has_return_body();
  inline void clear_has_return_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* index_;
  ::std::string* key_;
  ::std::string* range_min_;
  ::std::string* range_max_;
  int qtype_;
  ::google::protobuf::uint32 max_results_;
  ::std::string* continuation_;
  ::google::protobuf::uint32 timeout_;
  bool return_terms_;
  bool stream_;
  bool pagination_sort_;
  bool return_body_;
  ::std::string* type_;
  ::std::string* term_regex_;
  ::std::string* cover_context_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexResp : public ::google::protobuf::Message {
 public:
  RpbIndexResp();
  virtual ~RpbIndexResp();

  RpbIndexResp(const RpbIndexResp& from);

  inline RpbIndexResp& operator=(const RpbIndexResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexResp& default_instance();

  void Swap(RpbIndexResp* other);

  // implements Message ----------------------------------------------

  RpbIndexResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexResp& from);
  void MergeFrom(const RpbIndexResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated .RpbPair results = 2;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 2;
  inline const ::RpbPair& results(int index) const;
  inline ::RpbPair* mutable_results(int index);
  inline ::RpbPair* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_results();

  // optional bytes continuation = 3;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 3;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 4;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 4;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > results_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexBodyResp : public ::google::protobuf::Message {
 public:
  RpbIndexBodyResp();
  virtual ~RpbIndexBodyResp();

  RpbIndexBodyResp(const RpbIndexBodyResp& from);

  inline RpbIndexBodyResp& operator=(const RpbIndexBodyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexBodyResp& default_instance();

  void Swap(RpbIndexBodyResp* other);

  // implements Message ----------------------------------------------

  RpbIndexBodyResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexBodyResp& from);
  void MergeFrom(const RpbIndexBodyResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbIndexObject objects = 1;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 1;
  inline const ::RpbIndexObject& objects(int index) const;
  inline ::RpbIndexObject* mutable_objects(int index);
  inline ::RpbIndexObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
      mutable_objects();

  // optional bytes continuation = 2;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 2;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbIndexBodyResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbIndexObject > objects_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexBodyResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCSBucketReq : public ::google::protobuf::Message {
 public:
  RpbCSBucketReq();
  virtual ~RpbCSBucketReq();

  RpbCSBucketReq(const RpbCSBucketReq& from);

  inline RpbCSBucketReq& operator=(const RpbCSBucketReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCSBucketReq& default_instance();

  void Swap(RpbCSBucketReq* other);

  // implements Message ----------------------------------------------

  RpbCSBucketReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCSBucketReq& from);
  void MergeFrom(const RpbCSBucketReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes start_key = 2;
  inline bool has_start_key() const;
  inline void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  inline const ::std::string& start_key() const;
  inline void set_start_key(const ::std::string& value);
  inline void set_start_key(const char* value);
  inline void set_start_key(const void* value, size_t size);
  inline ::std::string* mutable_start_key();
  inline ::std::string* release_start_key();
  inline void set_allocated_start_key(::std::string* start_key);

  // optional bytes end_key = 3;
  inline bool has_end_key() const;
  inline void clear_end_key();
  static const int kEndKeyFieldNumber = 3;
  inline const ::std::string& end_key() const;
  inline void set_end_key(const ::std::string& value);
  inline void set_end_key(const char* value);
  inline void set_end_key(const void* value, size_t size);
  inline ::std::string* mutable_end_key();
  inline ::std::string* release_end_key();
  inline void set_allocated_end_key(::std::string* end_key);

  // optional bool start_incl = 4 [default = true];
  inline bool has_start_incl() const;
  inline void clear_start_incl();
  static const int kStartInclFieldNumber = 4;
  inline bool start_incl() const;
  inline void set_start_incl(bool value);

  // optional bool end_incl = 5 [default = false];
  inline bool has_end_incl() const;
  inline void clear_end_incl();
  static const int kEndInclFieldNumber = 5;
  inline bool end_incl() const;
  inline void set_end_incl(bool value);

  // optional bytes continuation = 6;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 6;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional uint32 max_results = 7;
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 7;
  inline ::google::protobuf::uint32 max_results() const;
  inline void set_max_results(::google::protobuf::uint32 value);

  // optional uint32 timeout = 8;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 timeout() const;
  inline void set_timeout(::google::protobuf::uint32 value);

  // optional bytes type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes cover_context = 10;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 10;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:RpbCSBucketReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_start_key();
  inline void clear_has_start_key();
  inline void set_has_end_key();
  inline void clear_has_end_key();
  inline void set_has_start_incl();
  inline void clear_has_start_incl();
  inline void set_has_end_incl();
  inline void clear_has_end_incl();
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_max_results();
  inline void clear_has_max_results();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* start_key_;
  ::std::string* end_key_;
  bool start_incl_;
  bool end_incl_;
  ::google::protobuf::uint32 max_results_;
  ::std::string* continuation_;
  ::std::string* type_;
  ::std::string* cover_context_;
  ::google::protobuf::uint32 timeout_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCSBucketReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCSBucketResp : public ::google::protobuf::Message {
 public:
  RpbCSBucketResp();
  virtual ~RpbCSBucketResp();

  RpbCSBucketResp(const RpbCSBucketResp& from);

  inline RpbCSBucketResp& operator=(const RpbCSBucketResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCSBucketResp& default_instance();

  void Swap(RpbCSBucketResp* other);

  // implements Message ----------------------------------------------

  RpbCSBucketResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCSBucketResp& from);
  void MergeFrom(const RpbCSBucketResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbIndexObject objects = 1;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 1;
  inline const ::RpbIndexObject& objects(int index) const;
  inline ::RpbIndexObject* mutable_objects(int index);
  inline ::RpbIndexObject* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
      mutable_objects();

  // optional bytes continuation = 2;
  inline bool has_continuation() const;
  inline void clear_continuation();
  static const int kContinuationFieldNumber = 2;
  inline const ::std::string& continuation() const;
  inline void set_continuation(const ::std::string& value);
  inline void set_continuation(const char* value);
  inline void set_continuation(const void* value, size_t size);
  inline ::std::string* mutable_continuation();
  inline ::std::string* release_continuation();
  inline void set_allocated_continuation(::std::string* continuation);

  // optional bool done = 3;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 3;
  inline bool done() const;
  inline void set_done(bool value);

  // @@protoc_insertion_point(class_scope:RpbCSBucketResp)
 private:
  inline void set_has_continuation();
  inline void clear_has_continuation();
  inline void set_has_done();
  inline void clear_has_done();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbIndexObject > objects_;
  ::std::string* continuation_;
  bool done_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCSBucketResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbIndexObject : public ::google::protobuf::Message {
 public:
  RpbIndexObject();
  virtual ~RpbIndexObject();

  RpbIndexObject(const RpbIndexObject& from);

  inline RpbIndexObject& operator=(const RpbIndexObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbIndexObject& default_instance();

  void Swap(RpbIndexObject* other);

  // implements Message ----------------------------------------------

  RpbIndexObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbIndexObject& from);
  void MergeFrom(const RpbIndexObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .RpbGetResp object = 2;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 2;
  inline const ::RpbGetResp& object() const;
  inline ::RpbGetResp* mutable_object();
  inline ::RpbGetResp* release_object();
  inline void set_allocated_object(::RpbGetResp* object);

  // @@protoc_insertion_point(class_scope:RpbIndexObject)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::RpbGetResp* object_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbIndexObject* default_instance_;
};
// -------------------------------------------------------------------

class RpbContent : public ::google::protobuf::Message {
 public:
  RpbContent();
  virtual ~RpbContent();

  RpbContent(const RpbContent& from);

  inline RpbContent& operator=(const RpbContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbContent& default_instance();

  void Swap(RpbContent* other);

  // implements Message ----------------------------------------------

  RpbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbContent& from);
  void MergeFrom(const RpbContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bytes content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // optional bytes charset = 3;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 3;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const void* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // optional bytes content_encoding = 4;
  inline bool has_content_encoding() const;
  inline void clear_content_encoding();
  static const int kContentEncodingFieldNumber = 4;
  inline const ::std::string& content_encoding() const;
  inline void set_content_encoding(const ::std::string& value);
  inline void set_content_encoding(const char* value);
  inline void set_content_encoding(const void* value, size_t size);
  inline ::std::string* mutable_content_encoding();
  inline ::std::string* release_content_encoding();
  inline void set_allocated_content_encoding(::std::string* content_encoding);

  // optional bytes vtag = 5;
  inline bool has_vtag() const;
  inline void clear_vtag();
  static const int kVtagFieldNumber = 5;
  inline const ::std::string& vtag() const;
  inline void set_vtag(const ::std::string& value);
  inline void set_vtag(const char* value);
  inline void set_vtag(const void* value, size_t size);
  inline ::std::string* mutable_vtag();
  inline ::std::string* release_vtag();
  inline void set_allocated_vtag(::std::string* vtag);

  // repeated .RpbLink links = 6;
  inline int links_size() const;
  inline void clear_links();
  static const int kLinksFieldNumber = 6;
  inline const ::RpbLink& links(int index) const;
  inline ::RpbLink* mutable_links(int index);
  inline ::RpbLink* add_links();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
      links() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
      mutable_links();

  // optional uint32 last_mod = 7;
  inline bool has_last_mod() const;
  inline void clear_last_mod();
  static const int kLastModFieldNumber = 7;
  inline ::google::protobuf::uint32 last_mod() const;
  inline void set_last_mod(::google::protobuf::uint32 value);

  // optional uint32 last_mod_usecs = 8;
  inline bool has_last_mod_usecs() const;
  inline void clear_last_mod_usecs();
  static const int kLastModUsecsFieldNumber = 8;
  inline ::google::protobuf::uint32 last_mod_usecs() const;
  inline void set_last_mod_usecs(::google::protobuf::uint32 value);

  // repeated .RpbPair usermeta = 9;
  inline int usermeta_size() const;
  inline void clear_usermeta();
  static const int kUsermetaFieldNumber = 9;
  inline const ::RpbPair& usermeta(int index) const;
  inline ::RpbPair* mutable_usermeta(int index);
  inline ::RpbPair* add_usermeta();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      usermeta() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_usermeta();

  // repeated .RpbPair indexes = 10;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 10;
  inline const ::RpbPair& indexes(int index) const;
  inline ::RpbPair* mutable_indexes(int index);
  inline ::RpbPair* add_indexes();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
      indexes() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
      mutable_indexes();

  // optional bool deleted = 11;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 11;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // @@protoc_insertion_point(class_scope:RpbContent)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_content_encoding();
  inline void clear_has_content_encoding();
  inline void set_has_vtag();
  inline void clear_has_vtag();
  inline void set_has_last_mod();
  inline void clear_has_last_mod();
  inline void set_has_last_mod_usecs();
  inline void clear_has_last_mod_usecs();
  inline void set_has_deleted();
  inline void clear_has_deleted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::std::string* content_type_;
  ::std::string* charset_;
  ::std::string* content_encoding_;
  ::std::string* vtag_;
  ::google::protobuf::RepeatedPtrField< ::RpbLink > links_;
  ::google::protobuf::uint32 last_mod_;
  ::google::protobuf::uint32 last_mod_usecs_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > usermeta_;
  ::google::protobuf::RepeatedPtrField< ::RpbPair > indexes_;
  bool deleted_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbContent* default_instance_;
};
// -------------------------------------------------------------------

class RpbLink : public ::google::protobuf::Message {
 public:
  RpbLink();
  virtual ~RpbLink();

  RpbLink(const RpbLink& from);

  inline RpbLink& operator=(const RpbLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbLink& default_instance();

  void Swap(RpbLink* other);

  // implements Message ----------------------------------------------

  RpbLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbLink& from);
  void MergeFrom(const RpbLink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:RpbLink)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* tag_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbLink* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterUpdateReq : public ::google::protobuf::Message {
 public:
  RpbCounterUpdateReq();
  virtual ~RpbCounterUpdateReq();

  RpbCounterUpdateReq(const RpbCounterUpdateReq& from);

  inline RpbCounterUpdateReq& operator=(const RpbCounterUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterUpdateReq& default_instance();

  void Swap(RpbCounterUpdateReq* other);

  // implements Message ----------------------------------------------

  RpbCounterUpdateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterUpdateReq& from);
  void MergeFrom(const RpbCounterUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required sint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::int64 amount() const;
  inline void set_amount(::google::protobuf::int64 value);

  // optional uint32 w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline ::google::protobuf::uint32 w() const;
  inline void set_w(::google::protobuf::uint32 value);

  // optional uint32 dw = 5;
  inline bool has_dw() const;
  inline void clear_dw();
  static const int kDwFieldNumber = 5;
  inline ::google::protobuf::uint32 dw() const;
  inline void set_dw(::google::protobuf::uint32 value);

  // optional uint32 pw = 6;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 6;
  inline ::google::protobuf::uint32 pw() const;
  inline void set_pw(::google::protobuf::uint32 value);

  // optional bool returnvalue = 7;
  inline bool has_returnvalue() const;
  inline void clear_returnvalue();
  static const int kReturnvalueFieldNumber = 7;
  inline bool returnvalue() const;
  inline void set_returnvalue(bool value);

  // @@protoc_insertion_point(class_scope:RpbCounterUpdateReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_dw();
  inline void clear_has_dw();
  inline void set_has_pw();
  inline void clear_has_pw();
  inline void set_has_returnvalue();
  inline void clear_has_returnvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::uint32 w_;
  ::google::protobuf::uint32 dw_;
  ::google::protobuf::uint32 pw_;
  bool returnvalue_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterUpdateResp : public ::google::protobuf::Message {
 public:
  RpbCounterUpdateResp();
  virtual ~RpbCounterUpdateResp();

  RpbCounterUpdateResp(const RpbCounterUpdateResp& from);

  inline RpbCounterUpdateResp& operator=(const RpbCounterUpdateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterUpdateResp& default_instance();

  void Swap(RpbCounterUpdateResp* other);

  // implements Message ----------------------------------------------

  RpbCounterUpdateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterUpdateResp& from);
  void MergeFrom(const RpbCounterUpdateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RpbCounterUpdateResp)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterUpdateResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterGetReq : public ::google::protobuf::Message {
 public:
  RpbCounterGetReq();
  virtual ~RpbCounterGetReq();

  RpbCounterGetReq(const RpbCounterGetReq& from);

  inline RpbCounterGetReq& operator=(const RpbCounterGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterGetReq& default_instance();

  void Swap(RpbCounterGetReq* other);

  // implements Message ----------------------------------------------

  RpbCounterGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterGetReq& from);
  void MergeFrom(const RpbCounterGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::uint32 r() const;
  inline void set_r(::google::protobuf::uint32 value);

  // optional uint32 pr = 4;
  inline bool has_pr() const;
  inline void clear_pr();
  static const int kPrFieldNumber = 4;
  inline ::google::protobuf::uint32 pr() const;
  inline void set_pr(::google::protobuf::uint32 value);

  // optional bool basic_quorum = 5;
  inline bool has_basic_quorum() const;
  inline void clear_basic_quorum();
  static const int kBasicQuorumFieldNumber = 5;
  inline bool basic_quorum() const;
  inline void set_basic_quorum(bool value);

  // optional bool notfound_ok = 6;
  inline bool has_notfound_ok() const;
  inline void clear_notfound_ok();
  static const int kNotfoundOkFieldNumber = 6;
  inline bool notfound_ok() const;
  inline void set_notfound_ok(bool value);

  // @@protoc_insertion_point(class_scope:RpbCounterGetReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_pr();
  inline void clear_has_pr();
  inline void set_has_basic_quorum();
  inline void clear_has_basic_quorum();
  inline void set_has_notfound_ok();
  inline void clear_has_notfound_ok();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 pr_;
  bool basic_quorum_;
  bool notfound_ok_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterGetReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCounterGetResp : public ::google::protobuf::Message {
 public:
  RpbCounterGetResp();
  virtual ~RpbCounterGetResp();

  RpbCounterGetResp(const RpbCounterGetResp& from);

  inline RpbCounterGetResp& operator=(const RpbCounterGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCounterGetResp& default_instance();

  void Swap(RpbCounterGetResp* other);

  // implements Message ----------------------------------------------

  RpbCounterGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCounterGetResp& from);
  void MergeFrom(const RpbCounterGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RpbCounterGetResp)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 value_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCounterGetResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketKeyPreflistReq : public ::google::protobuf::Message {
 public:
  RpbGetBucketKeyPreflistReq();
  virtual ~RpbGetBucketKeyPreflistReq();

  RpbGetBucketKeyPreflistReq(const RpbGetBucketKeyPreflistReq& from);

  inline RpbGetBucketKeyPreflistReq& operator=(const RpbGetBucketKeyPreflistReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketKeyPreflistReq& default_instance();

  void Swap(RpbGetBucketKeyPreflistReq* other);

  // implements Message ----------------------------------------------

  RpbGetBucketKeyPreflistReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketKeyPreflistReq& from);
  void MergeFrom(const RpbGetBucketKeyPreflistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes bucket = 1;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 1;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:RpbGetBucketKeyPreflistReq)
 private:
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* bucket_;
  ::std::string* key_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketKeyPreflistReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbGetBucketKeyPreflistResp : public ::google::protobuf::Message {
 public:
  RpbGetBucketKeyPreflistResp();
  virtual ~RpbGetBucketKeyPreflistResp();

  RpbGetBucketKeyPreflistResp(const RpbGetBucketKeyPreflistResp& from);

  inline RpbGetBucketKeyPreflistResp& operator=(const RpbGetBucketKeyPreflistResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbGetBucketKeyPreflistResp& default_instance();

  void Swap(RpbGetBucketKeyPreflistResp* other);

  // implements Message ----------------------------------------------

  RpbGetBucketKeyPreflistResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbGetBucketKeyPreflistResp& from);
  void MergeFrom(const RpbGetBucketKeyPreflistResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbBucketKeyPreflistItem preflist = 1;
  inline int preflist_size() const;
  inline void clear_preflist();
  static const int kPreflistFieldNumber = 1;
  inline const ::RpbBucketKeyPreflistItem& preflist(int index) const;
  inline ::RpbBucketKeyPreflistItem* mutable_preflist(int index);
  inline ::RpbBucketKeyPreflistItem* add_preflist();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >&
      preflist() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >*
      mutable_preflist();

  // @@protoc_insertion_point(class_scope:RpbGetBucketKeyPreflistResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem > preflist_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbGetBucketKeyPreflistResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbBucketKeyPreflistItem : public ::google::protobuf::Message {
 public:
  RpbBucketKeyPreflistItem();
  virtual ~RpbBucketKeyPreflistItem();

  RpbBucketKeyPreflistItem(const RpbBucketKeyPreflistItem& from);

  inline RpbBucketKeyPreflistItem& operator=(const RpbBucketKeyPreflistItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbBucketKeyPreflistItem& default_instance();

  void Swap(RpbBucketKeyPreflistItem* other);

  // implements Message ----------------------------------------------

  RpbBucketKeyPreflistItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbBucketKeyPreflistItem& from);
  void MergeFrom(const RpbBucketKeyPreflistItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 partition = 1;
  inline bool has_partition() const;
  inline void clear_partition();
  static const int kPartitionFieldNumber = 1;
  inline ::google::protobuf::int64 partition() const;
  inline void set_partition(::google::protobuf::int64 value);

  // required bytes node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // required bool primary = 3;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 3;
  inline bool primary() const;
  inline void set_primary(bool value);

  // @@protoc_insertion_point(class_scope:RpbBucketKeyPreflistItem)
 private:
  inline void set_has_partition();
  inline void clear_has_partition();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_primary();
  inline void clear_has_primary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 partition_;
  ::std::string* node_;
  bool primary_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbBucketKeyPreflistItem* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageReq : public ::google::protobuf::Message {
 public:
  RpbCoverageReq();
  virtual ~RpbCoverageReq();

  RpbCoverageReq(const RpbCoverageReq& from);

  inline RpbCoverageReq& operator=(const RpbCoverageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageReq& default_instance();

  void Swap(RpbCoverageReq* other);

  // implements Message ----------------------------------------------

  RpbCoverageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageReq& from);
  void MergeFrom(const RpbCoverageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const void* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required bytes bucket = 2;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 2;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const void* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional uint32 min_partitions = 3;
  inline bool has_min_partitions() const;
  inline void clear_min_partitions();
  static const int kMinPartitionsFieldNumber = 3;
  inline ::google::protobuf::uint32 min_partitions() const;
  inline void set_min_partitions(::google::protobuf::uint32 value);

  // optional bytes replace_cover = 4;
  inline bool has_replace_cover() const;
  inline void clear_replace_cover();
  static const int kReplaceCoverFieldNumber = 4;
  inline const ::std::string& replace_cover() const;
  inline void set_replace_cover(const ::std::string& value);
  inline void set_replace_cover(const char* value);
  inline void set_replace_cover(const void* value, size_t size);
  inline ::std::string* mutable_replace_cover();
  inline ::std::string* release_replace_cover();
  inline void set_allocated_replace_cover(::std::string* replace_cover);

  // repeated bytes unavailable_cover = 5;
  inline int unavailable_cover_size() const;
  inline void clear_unavailable_cover();
  static const int kUnavailableCoverFieldNumber = 5;
  inline const ::std::string& unavailable_cover(int index) const;
  inline ::std::string* mutable_unavailable_cover(int index);
  inline void set_unavailable_cover(int index, const ::std::string& value);
  inline void set_unavailable_cover(int index, const char* value);
  inline void set_unavailable_cover(int index, const void* value, size_t size);
  inline ::std::string* add_unavailable_cover();
  inline void add_unavailable_cover(const ::std::string& value);
  inline void add_unavailable_cover(const char* value);
  inline void add_unavailable_cover(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unavailable_cover() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unavailable_cover();

  // @@protoc_insertion_point(class_scope:RpbCoverageReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_min_partitions();
  inline void clear_has_min_partitions();
  inline void set_has_replace_cover();
  inline void clear_has_replace_cover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* bucket_;
  ::std::string* replace_cover_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unavailable_cover_;
  ::google::protobuf::uint32 min_partitions_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageReq* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageResp : public ::google::protobuf::Message {
 public:
  RpbCoverageResp();
  virtual ~RpbCoverageResp();

  RpbCoverageResp(const RpbCoverageResp& from);

  inline RpbCoverageResp& operator=(const RpbCoverageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageResp& default_instance();

  void Swap(RpbCoverageResp* other);

  // implements Message ----------------------------------------------

  RpbCoverageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageResp& from);
  void MergeFrom(const RpbCoverageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RpbCoverageEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::RpbCoverageEntry& entries(int index) const;
  inline ::RpbCoverageEntry* mutable_entries(int index);
  inline ::RpbCoverageEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:RpbCoverageResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry > entries_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageResp* default_instance_;
};
// -------------------------------------------------------------------

class RpbCoverageEntry : public ::google::protobuf::Message {
 public:
  RpbCoverageEntry();
  virtual ~RpbCoverageEntry();

  RpbCoverageEntry(const RpbCoverageEntry& from);

  inline RpbCoverageEntry& operator=(const RpbCoverageEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpbCoverageEntry& default_instance();

  void Swap(RpbCoverageEntry* other);

  // implements Message ----------------------------------------------

  RpbCoverageEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpbCoverageEntry& from);
  void MergeFrom(const RpbCoverageEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional bytes keyspace_desc = 3;
  inline bool has_keyspace_desc() const;
  inline void clear_keyspace_desc();
  static const int kKeyspaceDescFieldNumber = 3;
  inline const ::std::string& keyspace_desc() const;
  inline void set_keyspace_desc(const ::std::string& value);
  inline void set_keyspace_desc(const char* value);
  inline void set_keyspace_desc(const void* value, size_t size);
  inline ::std::string* mutable_keyspace_desc();
  inline ::std::string* release_keyspace_desc();
  inline void set_allocated_keyspace_desc(::std::string* keyspace_desc);

  // required bytes cover_context = 4;
  inline bool has_cover_context() const;
  inline void clear_cover_context();
  static const int kCoverContextFieldNumber = 4;
  inline const ::std::string& cover_context() const;
  inline void set_cover_context(const ::std::string& value);
  inline void set_cover_context(const char* value);
  inline void set_cover_context(const void* value, size_t size);
  inline ::std::string* mutable_cover_context();
  inline ::std::string* release_cover_context();
  inline void set_allocated_cover_context(::std::string* cover_context);

  // @@protoc_insertion_point(class_scope:RpbCoverageEntry)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_keyspace_desc();
  inline void clear_has_keyspace_desc();
  inline void set_has_cover_context();
  inline void clear_has_cover_context();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* keyspace_desc_;
  ::std::string* cover_context_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_riak_5fkv_2eproto();
  friend void protobuf_AssignDesc_riak_5fkv_2eproto();
  friend void protobuf_ShutdownFile_riak_5fkv_2eproto();

  void InitAsDefaultInstance();
  static RpbCoverageEntry* default_instance_;
};
// ===================================================================


// ===================================================================

// RpbGetClientIdResp

// required bytes client_id = 1;
inline bool RpbGetClientIdResp::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetClientIdResp::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetClientIdResp::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetClientIdResp::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbGetClientIdResp::client_id() const {
  // @@protoc_insertion_point(field_get:RpbGetClientIdResp.client_id)
  return *client_id_;
}
inline void RpbGetClientIdResp::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetClientIdResp.client_id)
}
inline void RpbGetClientIdResp::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetClientIdResp.client_id)
}
inline void RpbGetClientIdResp::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetClientIdResp.client_id)
}
inline ::std::string* RpbGetClientIdResp::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetClientIdResp.client_id)
  return client_id_;
}
inline ::std::string* RpbGetClientIdResp::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetClientIdResp::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetClientIdResp.client_id)
}

// -------------------------------------------------------------------

// RpbSetClientIdReq

// required bytes client_id = 1;
inline bool RpbSetClientIdReq::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbSetClientIdReq::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbSetClientIdReq::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbSetClientIdReq::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& RpbSetClientIdReq::client_id() const {
  // @@protoc_insertion_point(field_get:RpbSetClientIdReq.client_id)
  return *client_id_;
}
inline void RpbSetClientIdReq::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:RpbSetClientIdReq.client_id)
}
inline void RpbSetClientIdReq::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbSetClientIdReq.client_id)
}
inline void RpbSetClientIdReq::set_client_id(const void* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbSetClientIdReq.client_id)
}
inline ::std::string* RpbSetClientIdReq::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbSetClientIdReq.client_id)
  return client_id_;
}
inline ::std::string* RpbSetClientIdReq::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbSetClientIdReq::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbSetClientIdReq.client_id)
}

// -------------------------------------------------------------------

// RpbGetReq

// required bytes bucket = 1;
inline bool RpbGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.bucket)
  return *bucket_;
}
inline void RpbGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.bucket)
}
inline void RpbGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.bucket)
}
inline void RpbGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.bucket)
}
inline ::std::string* RpbGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.bucket)
  return bucket_;
}
inline ::std::string* RpbGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.bucket)
}

// required bytes key = 2;
inline bool RpbGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetReq::key() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.key)
  return *key_;
}
inline void RpbGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.key)
}
inline void RpbGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.key)
}
inline void RpbGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.key)
}
inline ::std::string* RpbGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.key)
  return key_;
}
inline ::std::string* RpbGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.key)
}

// optional uint32 r = 3;
inline bool RpbGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbGetReq::r() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.r)
  return r_;
}
inline void RpbGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.r)
}

// optional uint32 pr = 4;
inline bool RpbGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbGetReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.pr)
  return pr_;
}
inline void RpbGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.pr)
}

// optional bool basic_quorum = 5;
inline bool RpbGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbGetReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.basic_quorum)
  return basic_quorum_;
}
inline void RpbGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.basic_quorum)
}

// optional bool notfound_ok = 6;
inline bool RpbGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbGetReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.notfound_ok)
  return notfound_ok_;
}
inline void RpbGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.notfound_ok)
}

// optional bytes if_modified = 7;
inline bool RpbGetReq::has_if_modified() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbGetReq::set_has_if_modified() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbGetReq::clear_has_if_modified() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbGetReq::clear_if_modified() {
  if (if_modified_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_->clear();
  }
  clear_has_if_modified();
}
inline const ::std::string& RpbGetReq::if_modified() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.if_modified)
  return *if_modified_;
}
inline void RpbGetReq::set_if_modified(const ::std::string& value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.if_modified)
}
inline void RpbGetReq::set_if_modified(const char* value) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.if_modified)
}
inline void RpbGetReq::set_if_modified(const void* value, size_t size) {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  if_modified_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.if_modified)
}
inline ::std::string* RpbGetReq::mutable_if_modified() {
  set_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    if_modified_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.if_modified)
  return if_modified_;
}
inline ::std::string* RpbGetReq::release_if_modified() {
  clear_has_if_modified();
  if (if_modified_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = if_modified_;
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_if_modified(::std::string* if_modified) {
  if (if_modified_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete if_modified_;
  }
  if (if_modified) {
    set_has_if_modified();
    if_modified_ = if_modified;
  } else {
    clear_has_if_modified();
    if_modified_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.if_modified)
}

// optional bool head = 8;
inline bool RpbGetReq::has_head() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbGetReq::set_has_head() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbGetReq::clear_has_head() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbGetReq::clear_head() {
  head_ = false;
  clear_has_head();
}
inline bool RpbGetReq::head() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.head)
  return head_;
}
inline void RpbGetReq::set_head(bool value) {
  set_has_head();
  head_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.head)
}

// optional bool deletedvclock = 9;
inline bool RpbGetReq::has_deletedvclock() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbGetReq::set_has_deletedvclock() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbGetReq::clear_has_deletedvclock() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbGetReq::clear_deletedvclock() {
  deletedvclock_ = false;
  clear_has_deletedvclock();
}
inline bool RpbGetReq::deletedvclock() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.deletedvclock)
  return deletedvclock_;
}
inline void RpbGetReq::set_deletedvclock(bool value) {
  set_has_deletedvclock();
  deletedvclock_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.deletedvclock)
}

// optional uint32 timeout = 10;
inline bool RpbGetReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbGetReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbGetReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbGetReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbGetReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.timeout)
  return timeout_;
}
inline void RpbGetReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool RpbGetReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbGetReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbGetReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbGetReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbGetReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbGetReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool RpbGetReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbGetReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbGetReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbGetReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbGetReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.n_val)
  return n_val_;
}
inline void RpbGetReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbGetReq.n_val)
}

// optional bytes type = 13;
inline bool RpbGetReq::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbGetReq::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbGetReq::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbGetReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetReq.type)
  return *type_;
}
inline void RpbGetReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetReq.type)
}
inline void RpbGetReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetReq.type)
}
inline void RpbGetReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetReq.type)
}
inline ::std::string* RpbGetReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetReq.type)
  return type_;
}
inline ::std::string* RpbGetReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetReq.type)
}

// -------------------------------------------------------------------

// RpbGetResp

// repeated .RpbContent content = 1;
inline int RpbGetResp::content_size() const {
  return content_.size();
}
inline void RpbGetResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbGetResp::content(int index) const {
  // @@protoc_insertion_point(field_get:RpbGetResp.content)
  return content_.Get(index);
}
inline ::RpbContent* RpbGetResp::mutable_content(int index) {
  // @@protoc_insertion_point(field_mutable:RpbGetResp.content)
  return content_.Mutable(index);
}
inline ::RpbContent* RpbGetResp::add_content() {
  // @@protoc_insertion_point(field_add:RpbGetResp.content)
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbGetResp::content() const {
  // @@protoc_insertion_point(field_list:RpbGetResp.content)
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbGetResp::mutable_content() {
  // @@protoc_insertion_point(field_mutable_list:RpbGetResp.content)
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbGetResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbGetResp::vclock() const {
  // @@protoc_insertion_point(field_get:RpbGetResp.vclock)
  return *vclock_;
}
inline void RpbGetResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetResp.vclock)
}
inline void RpbGetResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetResp.vclock)
}
inline void RpbGetResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetResp.vclock)
}
inline ::std::string* RpbGetResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetResp.vclock)
  return vclock_;
}
inline ::std::string* RpbGetResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetResp::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetResp.vclock)
}

// optional bool unchanged = 3;
inline bool RpbGetResp::has_unchanged() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetResp::set_has_unchanged() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetResp::clear_has_unchanged() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetResp::clear_unchanged() {
  unchanged_ = false;
  clear_has_unchanged();
}
inline bool RpbGetResp::unchanged() const {
  // @@protoc_insertion_point(field_get:RpbGetResp.unchanged)
  return unchanged_;
}
inline void RpbGetResp::set_unchanged(bool value) {
  set_has_unchanged();
  unchanged_ = value;
  // @@protoc_insertion_point(field_set:RpbGetResp.unchanged)
}

// -------------------------------------------------------------------

// RpbPutReq

// required bytes bucket = 1;
inline bool RpbPutReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbPutReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbPutReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbPutReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbPutReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.bucket)
  return *bucket_;
}
inline void RpbPutReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.bucket)
}
inline void RpbPutReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.bucket)
}
inline void RpbPutReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.bucket)
}
inline ::std::string* RpbPutReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.bucket)
  return bucket_;
}
inline ::std::string* RpbPutReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.bucket)
}

// optional bytes key = 2;
inline bool RpbPutReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutReq::key() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.key)
  return *key_;
}
inline void RpbPutReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.key)
}
inline void RpbPutReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.key)
}
inline void RpbPutReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.key)
}
inline ::std::string* RpbPutReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.key)
  return key_;
}
inline ::std::string* RpbPutReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.key)
}

// optional bytes vclock = 3;
inline bool RpbPutReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutReq::vclock() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.vclock)
  return *vclock_;
}
inline void RpbPutReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.vclock)
}
inline void RpbPutReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.vclock)
}
inline void RpbPutReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.vclock)
}
inline ::std::string* RpbPutReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.vclock)
  return vclock_;
}
inline ::std::string* RpbPutReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.vclock)
}

// required .RpbContent content = 4;
inline bool RpbPutReq::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbPutReq::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbPutReq::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbPutReq::clear_content() {
  if (content_ != NULL) content_->::RpbContent::Clear();
  clear_has_content();
}
inline const ::RpbContent& RpbPutReq::content() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.content)
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::RpbContent* RpbPutReq::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::RpbContent;
  // @@protoc_insertion_point(field_mutable:RpbPutReq.content)
  return content_;
}
inline ::RpbContent* RpbPutReq::release_content() {
  clear_has_content();
  ::RpbContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline void RpbPutReq::set_allocated_content(::RpbContent* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.content)
}

// optional uint32 w = 5;
inline bool RpbPutReq::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbPutReq::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbPutReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbPutReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbPutReq::w() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.w)
  return w_;
}
inline void RpbPutReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.w)
}

// optional uint32 dw = 6;
inline bool RpbPutReq::has_dw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbPutReq::set_has_dw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbPutReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbPutReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbPutReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.dw)
  return dw_;
}
inline void RpbPutReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.dw)
}

// optional bool return_body = 7;
inline bool RpbPutReq::has_return_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbPutReq::set_has_return_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbPutReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbPutReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbPutReq::return_body() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.return_body)
  return return_body_;
}
inline void RpbPutReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.return_body)
}

// optional uint32 pw = 8;
inline bool RpbPutReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbPutReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbPutReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbPutReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbPutReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.pw)
  return pw_;
}
inline void RpbPutReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.pw)
}

// optional bool if_not_modified = 9;
inline bool RpbPutReq::has_if_not_modified() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbPutReq::set_has_if_not_modified() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbPutReq::clear_has_if_not_modified() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbPutReq::clear_if_not_modified() {
  if_not_modified_ = false;
  clear_has_if_not_modified();
}
inline bool RpbPutReq::if_not_modified() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.if_not_modified)
  return if_not_modified_;
}
inline void RpbPutReq::set_if_not_modified(bool value) {
  set_has_if_not_modified();
  if_not_modified_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.if_not_modified)
}

// optional bool if_none_match = 10;
inline bool RpbPutReq::has_if_none_match() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbPutReq::set_has_if_none_match() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbPutReq::clear_has_if_none_match() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbPutReq::clear_if_none_match() {
  if_none_match_ = false;
  clear_has_if_none_match();
}
inline bool RpbPutReq::if_none_match() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.if_none_match)
  return if_none_match_;
}
inline void RpbPutReq::set_if_none_match(bool value) {
  set_has_if_none_match();
  if_none_match_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.if_none_match)
}

// optional bool return_head = 11;
inline bool RpbPutReq::has_return_head() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbPutReq::set_has_return_head() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbPutReq::clear_has_return_head() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbPutReq::clear_return_head() {
  return_head_ = false;
  clear_has_return_head();
}
inline bool RpbPutReq::return_head() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.return_head)
  return return_head_;
}
inline void RpbPutReq::set_return_head(bool value) {
  set_has_return_head();
  return_head_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.return_head)
}

// optional uint32 timeout = 12;
inline bool RpbPutReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbPutReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbPutReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbPutReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbPutReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.timeout)
  return timeout_;
}
inline void RpbPutReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.timeout)
}

// optional bool asis = 13;
inline bool RpbPutReq::has_asis() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbPutReq::set_has_asis() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbPutReq::clear_has_asis() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbPutReq::clear_asis() {
  asis_ = false;
  clear_has_asis();
}
inline bool RpbPutReq::asis() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.asis)
  return asis_;
}
inline void RpbPutReq::set_asis(bool value) {
  set_has_asis();
  asis_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.asis)
}

// optional bool sloppy_quorum = 14;
inline bool RpbPutReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RpbPutReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RpbPutReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RpbPutReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbPutReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbPutReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.sloppy_quorum)
}

// optional uint32 n_val = 15;
inline bool RpbPutReq::has_n_val() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RpbPutReq::set_has_n_val() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RpbPutReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RpbPutReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbPutReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.n_val)
  return n_val_;
}
inline void RpbPutReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbPutReq.n_val)
}

// optional bytes type = 16;
inline bool RpbPutReq::has_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RpbPutReq::set_has_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RpbPutReq::clear_has_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RpbPutReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbPutReq::type() const {
  // @@protoc_insertion_point(field_get:RpbPutReq.type)
  return *type_;
}
inline void RpbPutReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutReq.type)
}
inline void RpbPutReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutReq.type)
}
inline void RpbPutReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutReq.type)
}
inline ::std::string* RpbPutReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutReq.type)
  return type_;
}
inline ::std::string* RpbPutReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutReq.type)
}

// -------------------------------------------------------------------

// RpbPutResp

// repeated .RpbContent content = 1;
inline int RpbPutResp::content_size() const {
  return content_.size();
}
inline void RpbPutResp::clear_content() {
  content_.Clear();
}
inline const ::RpbContent& RpbPutResp::content(int index) const {
  // @@protoc_insertion_point(field_get:RpbPutResp.content)
  return content_.Get(index);
}
inline ::RpbContent* RpbPutResp::mutable_content(int index) {
  // @@protoc_insertion_point(field_mutable:RpbPutResp.content)
  return content_.Mutable(index);
}
inline ::RpbContent* RpbPutResp::add_content() {
  // @@protoc_insertion_point(field_add:RpbPutResp.content)
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbContent >&
RpbPutResp::content() const {
  // @@protoc_insertion_point(field_list:RpbPutResp.content)
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbContent >*
RpbPutResp::mutable_content() {
  // @@protoc_insertion_point(field_mutable_list:RpbPutResp.content)
  return &content_;
}

// optional bytes vclock = 2;
inline bool RpbPutResp::has_vclock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbPutResp::set_has_vclock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbPutResp::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbPutResp::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbPutResp::vclock() const {
  // @@protoc_insertion_point(field_get:RpbPutResp.vclock)
  return *vclock_;
}
inline void RpbPutResp::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutResp.vclock)
}
inline void RpbPutResp::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutResp.vclock)
}
inline void RpbPutResp::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutResp.vclock)
}
inline ::std::string* RpbPutResp::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutResp.vclock)
  return vclock_;
}
inline ::std::string* RpbPutResp::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutResp::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutResp.vclock)
}

// optional bytes key = 3;
inline bool RpbPutResp::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbPutResp::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbPutResp::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbPutResp::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbPutResp::key() const {
  // @@protoc_insertion_point(field_get:RpbPutResp.key)
  return *key_;
}
inline void RpbPutResp::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbPutResp.key)
}
inline void RpbPutResp::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbPutResp.key)
}
inline void RpbPutResp::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbPutResp.key)
}
inline ::std::string* RpbPutResp::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbPutResp.key)
  return key_;
}
inline ::std::string* RpbPutResp::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbPutResp::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbPutResp.key)
}

// -------------------------------------------------------------------

// RpbDelReq

// required bytes bucket = 1;
inline bool RpbDelReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbDelReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbDelReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbDelReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbDelReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.bucket)
  return *bucket_;
}
inline void RpbDelReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.bucket)
}
inline void RpbDelReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.bucket)
}
inline void RpbDelReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.bucket)
}
inline ::std::string* RpbDelReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.bucket)
  return bucket_;
}
inline ::std::string* RpbDelReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.bucket)
}

// required bytes key = 2;
inline bool RpbDelReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbDelReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbDelReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbDelReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbDelReq::key() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.key)
  return *key_;
}
inline void RpbDelReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.key)
}
inline void RpbDelReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.key)
}
inline void RpbDelReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.key)
}
inline ::std::string* RpbDelReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.key)
  return key_;
}
inline ::std::string* RpbDelReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.key)
}

// optional uint32 rw = 3;
inline bool RpbDelReq::has_rw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbDelReq::set_has_rw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbDelReq::clear_has_rw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbDelReq::clear_rw() {
  rw_ = 0u;
  clear_has_rw();
}
inline ::google::protobuf::uint32 RpbDelReq::rw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.rw)
  return rw_;
}
inline void RpbDelReq::set_rw(::google::protobuf::uint32 value) {
  set_has_rw();
  rw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.rw)
}

// optional bytes vclock = 4;
inline bool RpbDelReq::has_vclock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbDelReq::set_has_vclock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbDelReq::clear_has_vclock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbDelReq::clear_vclock() {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_->clear();
  }
  clear_has_vclock();
}
inline const ::std::string& RpbDelReq::vclock() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.vclock)
  return *vclock_;
}
inline void RpbDelReq::set_vclock(const ::std::string& value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.vclock)
}
inline void RpbDelReq::set_vclock(const char* value) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.vclock)
}
inline void RpbDelReq::set_vclock(const void* value, size_t size) {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  vclock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.vclock)
}
inline ::std::string* RpbDelReq::mutable_vclock() {
  set_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vclock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.vclock)
  return vclock_;
}
inline ::std::string* RpbDelReq::release_vclock() {
  clear_has_vclock();
  if (vclock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vclock_;
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_vclock(::std::string* vclock) {
  if (vclock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vclock_;
  }
  if (vclock) {
    set_has_vclock();
    vclock_ = vclock;
  } else {
    clear_has_vclock();
    vclock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.vclock)
}

// optional uint32 r = 5;
inline bool RpbDelReq::has_r() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbDelReq::set_has_r() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbDelReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbDelReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbDelReq::r() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.r)
  return r_;
}
inline void RpbDelReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.r)
}

// optional uint32 w = 6;
inline bool RpbDelReq::has_w() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbDelReq::set_has_w() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbDelReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbDelReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbDelReq::w() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.w)
  return w_;
}
inline void RpbDelReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.w)
}

// optional uint32 pr = 7;
inline bool RpbDelReq::has_pr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbDelReq::set_has_pr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbDelReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbDelReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbDelReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.pr)
  return pr_;
}
inline void RpbDelReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.pr)
}

// optional uint32 pw = 8;
inline bool RpbDelReq::has_pw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbDelReq::set_has_pw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbDelReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbDelReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbDelReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.pw)
  return pw_;
}
inline void RpbDelReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.pw)
}

// optional uint32 dw = 9;
inline bool RpbDelReq::has_dw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbDelReq::set_has_dw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbDelReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbDelReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbDelReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.dw)
  return dw_;
}
inline void RpbDelReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.dw)
}

// optional uint32 timeout = 10;
inline bool RpbDelReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbDelReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbDelReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbDelReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbDelReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.timeout)
  return timeout_;
}
inline void RpbDelReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.timeout)
}

// optional bool sloppy_quorum = 11;
inline bool RpbDelReq::has_sloppy_quorum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbDelReq::set_has_sloppy_quorum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbDelReq::clear_has_sloppy_quorum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbDelReq::clear_sloppy_quorum() {
  sloppy_quorum_ = false;
  clear_has_sloppy_quorum();
}
inline bool RpbDelReq::sloppy_quorum() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.sloppy_quorum)
  return sloppy_quorum_;
}
inline void RpbDelReq::set_sloppy_quorum(bool value) {
  set_has_sloppy_quorum();
  sloppy_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.sloppy_quorum)
}

// optional uint32 n_val = 12;
inline bool RpbDelReq::has_n_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbDelReq::set_has_n_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbDelReq::clear_has_n_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbDelReq::clear_n_val() {
  n_val_ = 0u;
  clear_has_n_val();
}
inline ::google::protobuf::uint32 RpbDelReq::n_val() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.n_val)
  return n_val_;
}
inline void RpbDelReq::set_n_val(::google::protobuf::uint32 value) {
  set_has_n_val();
  n_val_ = value;
  // @@protoc_insertion_point(field_set:RpbDelReq.n_val)
}

// optional bytes type = 13;
inline bool RpbDelReq::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbDelReq::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbDelReq::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbDelReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbDelReq::type() const {
  // @@protoc_insertion_point(field_get:RpbDelReq.type)
  return *type_;
}
inline void RpbDelReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbDelReq.type)
}
inline void RpbDelReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbDelReq.type)
}
inline void RpbDelReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbDelReq.type)
}
inline ::std::string* RpbDelReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbDelReq.type)
  return type_;
}
inline ::std::string* RpbDelReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbDelReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbDelReq.type)
}

// -------------------------------------------------------------------

// RpbListBucketsReq

// optional uint32 timeout = 1;
inline bool RpbListBucketsReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListBucketsReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListBucketsReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListBucketsReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbListBucketsReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.timeout)
  return timeout_;
}
inline void RpbListBucketsReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.timeout)
}

// optional bool stream = 2;
inline bool RpbListBucketsReq::has_stream() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListBucketsReq::set_has_stream() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListBucketsReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListBucketsReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool RpbListBucketsReq::stream() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.stream)
  return stream_;
}
inline void RpbListBucketsReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.stream)
}

// optional bytes type = 3;
inline bool RpbListBucketsReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbListBucketsReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbListBucketsReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbListBucketsReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbListBucketsReq::type() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsReq.type)
  return *type_;
}
inline void RpbListBucketsReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListBucketsReq.type)
}
inline void RpbListBucketsReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListBucketsReq.type)
}
inline void RpbListBucketsReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListBucketsReq.type)
}
inline ::std::string* RpbListBucketsReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListBucketsReq.type)
  return type_;
}
inline ::std::string* RpbListBucketsReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListBucketsReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListBucketsReq.type)
}

// -------------------------------------------------------------------

// RpbListBucketsResp

// repeated bytes buckets = 1;
inline int RpbListBucketsResp::buckets_size() const {
  return buckets_.size();
}
inline void RpbListBucketsResp::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& RpbListBucketsResp::buckets(int index) const {
  // @@protoc_insertion_point(field_get:RpbListBucketsResp.buckets)
  return buckets_.Get(index);
}
inline ::std::string* RpbListBucketsResp::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:RpbListBucketsResp.buckets)
  return buckets_.Mutable(index);
}
inline void RpbListBucketsResp::set_buckets(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbListBucketsResp.buckets)
  buckets_.Mutable(index)->assign(value);
}
inline void RpbListBucketsResp::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::set_buckets(int index, const void* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListBucketsResp.buckets)
}
inline ::std::string* RpbListBucketsResp::add_buckets() {
  return buckets_.Add();
}
inline void RpbListBucketsResp::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbListBucketsResp.buckets)
}
inline void RpbListBucketsResp::add_buckets(const void* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbListBucketsResp.buckets)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListBucketsResp::buckets() const {
  // @@protoc_insertion_point(field_list:RpbListBucketsResp.buckets)
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListBucketsResp::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:RpbListBucketsResp.buckets)
  return &buckets_;
}

// optional bool done = 2;
inline bool RpbListBucketsResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListBucketsResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListBucketsResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListBucketsResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListBucketsResp::done() const {
  // @@protoc_insertion_point(field_get:RpbListBucketsResp.done)
  return done_;
}
inline void RpbListBucketsResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbListBucketsResp.done)
}

// -------------------------------------------------------------------

// RpbListKeysReq

// required bytes bucket = 1;
inline bool RpbListKeysReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbListKeysReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbListKeysReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbListKeysReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbListKeysReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.bucket)
  return *bucket_;
}
inline void RpbListKeysReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListKeysReq.bucket)
}
inline void RpbListKeysReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysReq.bucket)
}
inline void RpbListKeysReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysReq.bucket)
}
inline ::std::string* RpbListKeysReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListKeysReq.bucket)
  return bucket_;
}
inline ::std::string* RpbListKeysReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListKeysReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListKeysReq.bucket)
}

// optional uint32 timeout = 2;
inline bool RpbListKeysReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbListKeysReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.timeout)
  return timeout_;
}
inline void RpbListKeysReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbListKeysReq.timeout)
}

// optional bytes type = 3;
inline bool RpbListKeysReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbListKeysReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbListKeysReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbListKeysReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbListKeysReq::type() const {
  // @@protoc_insertion_point(field_get:RpbListKeysReq.type)
  return *type_;
}
inline void RpbListKeysReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbListKeysReq.type)
}
inline void RpbListKeysReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysReq.type)
}
inline void RpbListKeysReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysReq.type)
}
inline ::std::string* RpbListKeysReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbListKeysReq.type)
  return type_;
}
inline ::std::string* RpbListKeysReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbListKeysReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbListKeysReq.type)
}

// -------------------------------------------------------------------

// RpbListKeysResp

// repeated bytes keys = 1;
inline int RpbListKeysResp::keys_size() const {
  return keys_.size();
}
inline void RpbListKeysResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbListKeysResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:RpbListKeysResp.keys)
  return keys_.Get(index);
}
inline ::std::string* RpbListKeysResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:RpbListKeysResp.keys)
  return keys_.Mutable(index);
}
inline void RpbListKeysResp::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbListKeysResp.keys)
  keys_.Mutable(index)->assign(value);
}
inline void RpbListKeysResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbListKeysResp.keys)
}
inline ::std::string* RpbListKeysResp::add_keys() {
  return keys_.Add();
}
inline void RpbListKeysResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbListKeysResp.keys)
}
inline void RpbListKeysResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbListKeysResp.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbListKeysResp::keys() const {
  // @@protoc_insertion_point(field_list:RpbListKeysResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbListKeysResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:RpbListKeysResp.keys)
  return &keys_;
}

// optional bool done = 2;
inline bool RpbListKeysResp::has_done() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbListKeysResp::set_has_done() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbListKeysResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbListKeysResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbListKeysResp::done() const {
  // @@protoc_insertion_point(field_get:RpbListKeysResp.done)
  return done_;
}
inline void RpbListKeysResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbListKeysResp.done)
}

// -------------------------------------------------------------------

// RpbMapRedReq

// required bytes request = 1;
inline bool RpbMapRedReq::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedReq::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedReq::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedReq::clear_request() {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& RpbMapRedReq::request() const {
  // @@protoc_insertion_point(field_get:RpbMapRedReq.request)
  return *request_;
}
inline void RpbMapRedReq::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedReq.request)
}
inline void RpbMapRedReq::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedReq.request)
}
inline void RpbMapRedReq::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedReq.request)
}
inline ::std::string* RpbMapRedReq::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedReq.request)
  return request_;
}
inline ::std::string* RpbMapRedReq::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedReq::set_allocated_request(::std::string* request) {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_;
  }
  if (request) {
    set_has_request();
    request_ = request;
  } else {
    clear_has_request();
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedReq.request)
}

// required bytes content_type = 2;
inline bool RpbMapRedReq::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedReq::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedReq::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedReq::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbMapRedReq::content_type() const {
  // @@protoc_insertion_point(field_get:RpbMapRedReq.content_type)
  return *content_type_;
}
inline void RpbMapRedReq::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedReq.content_type)
}
inline void RpbMapRedReq::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedReq.content_type)
}
inline void RpbMapRedReq::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedReq.content_type)
}
inline ::std::string* RpbMapRedReq::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedReq.content_type)
  return content_type_;
}
inline ::std::string* RpbMapRedReq::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedReq::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedReq.content_type)
}

// -------------------------------------------------------------------

// RpbMapRedResp

// optional uint32 phase = 1;
inline bool RpbMapRedResp::has_phase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbMapRedResp::set_has_phase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbMapRedResp::clear_has_phase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbMapRedResp::clear_phase() {
  phase_ = 0u;
  clear_has_phase();
}
inline ::google::protobuf::uint32 RpbMapRedResp::phase() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.phase)
  return phase_;
}
inline void RpbMapRedResp::set_phase(::google::protobuf::uint32 value) {
  set_has_phase();
  phase_ = value;
  // @@protoc_insertion_point(field_set:RpbMapRedResp.phase)
}

// optional bytes response = 2;
inline bool RpbMapRedResp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbMapRedResp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbMapRedResp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbMapRedResp::clear_response() {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& RpbMapRedResp::response() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.response)
  return *response_;
}
inline void RpbMapRedResp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set:RpbMapRedResp.response)
}
inline void RpbMapRedResp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbMapRedResp.response)
}
inline void RpbMapRedResp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbMapRedResp.response)
}
inline ::std::string* RpbMapRedResp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbMapRedResp.response)
  return response_;
}
inline ::std::string* RpbMapRedResp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbMapRedResp::set_allocated_response(::std::string* response) {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_;
  }
  if (response) {
    set_has_response();
    response_ = response;
  } else {
    clear_has_response();
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbMapRedResp.response)
}

// optional bool done = 3;
inline bool RpbMapRedResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbMapRedResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbMapRedResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbMapRedResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbMapRedResp::done() const {
  // @@protoc_insertion_point(field_get:RpbMapRedResp.done)
  return done_;
}
inline void RpbMapRedResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbMapRedResp.done)
}

// -------------------------------------------------------------------

// RpbIndexReq

// required bytes bucket = 1;
inline bool RpbIndexReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbIndexReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbIndexReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbIndexReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbIndexReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.bucket)
  return *bucket_;
}
inline void RpbIndexReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.bucket)
}
inline void RpbIndexReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.bucket)
}
inline void RpbIndexReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.bucket)
}
inline ::std::string* RpbIndexReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.bucket)
  return bucket_;
}
inline ::std::string* RpbIndexReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.bucket)
}

// required bytes index = 2;
inline bool RpbIndexReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexReq::clear_index() {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_->clear();
  }
  clear_has_index();
}
inline const ::std::string& RpbIndexReq::index() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.index)
  return *index_;
}
inline void RpbIndexReq::set_index(const ::std::string& value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.index)
}
inline void RpbIndexReq::set_index(const char* value) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.index)
}
inline void RpbIndexReq::set_index(const void* value, size_t size) {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.index)
}
inline ::std::string* RpbIndexReq::mutable_index() {
  set_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.index)
  return index_;
}
inline ::std::string* RpbIndexReq::release_index() {
  clear_has_index();
  if (index_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = index_;
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_index(::std::string* index) {
  if (index_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete index_;
  }
  if (index) {
    set_has_index();
    index_ = index;
  } else {
    clear_has_index();
    index_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.index)
}

// required .RpbIndexReq.IndexQueryType qtype = 3;
inline bool RpbIndexReq::has_qtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexReq::set_has_qtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexReq::clear_has_qtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexReq::clear_qtype() {
  qtype_ = 0;
  clear_has_qtype();
}
inline ::RpbIndexReq_IndexQueryType RpbIndexReq::qtype() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.qtype)
  return static_cast< ::RpbIndexReq_IndexQueryType >(qtype_);
}
inline void RpbIndexReq::set_qtype(::RpbIndexReq_IndexQueryType value) {
  assert(::RpbIndexReq_IndexQueryType_IsValid(value));
  set_has_qtype();
  qtype_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.qtype)
}

// optional bytes key = 4;
inline bool RpbIndexReq::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbIndexReq::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbIndexReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbIndexReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbIndexReq::key() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.key)
  return *key_;
}
inline void RpbIndexReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.key)
}
inline void RpbIndexReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.key)
}
inline void RpbIndexReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.key)
}
inline ::std::string* RpbIndexReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.key)
  return key_;
}
inline ::std::string* RpbIndexReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.key)
}

// optional bytes range_min = 5;
inline bool RpbIndexReq::has_range_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbIndexReq::set_has_range_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbIndexReq::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbIndexReq::clear_range_min() {
  if (range_min_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_->clear();
  }
  clear_has_range_min();
}
inline const ::std::string& RpbIndexReq::range_min() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.range_min)
  return *range_min_;
}
inline void RpbIndexReq::set_range_min(const ::std::string& value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.range_min)
}
inline void RpbIndexReq::set_range_min(const char* value) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.range_min)
}
inline void RpbIndexReq::set_range_min(const void* value, size_t size) {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  range_min_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.range_min)
}
inline ::std::string* RpbIndexReq::mutable_range_min() {
  set_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_min_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.range_min)
  return range_min_;
}
inline ::std::string* RpbIndexReq::release_range_min() {
  clear_has_range_min();
  if (range_min_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = range_min_;
    range_min_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_range_min(::std::string* range_min) {
  if (range_min_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete range_min_;
  }
  if (range_min) {
    set_has_range_min();
    range_min_ = range_min;
  } else {
    clear_has_range_min();
    range_min_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.range_min)
}

// optional bytes range_max = 6;
inline bool RpbIndexReq::has_range_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbIndexReq::set_has_range_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbIndexReq::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbIndexReq::clear_range_max() {
  if (range_max_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_->clear();
  }
  clear_has_range_max();
}
inline const ::std::string& RpbIndexReq::range_max() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.range_max)
  return *range_max_;
}
inline void RpbIndexReq::set_range_max(const ::std::string& value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.range_max)
}
inline void RpbIndexReq::set_range_max(const char* value) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.range_max)
}
inline void RpbIndexReq::set_range_max(const void* value, size_t size) {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  range_max_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.range_max)
}
inline ::std::string* RpbIndexReq::mutable_range_max() {
  set_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    range_max_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.range_max)
  return range_max_;
}
inline ::std::string* RpbIndexReq::release_range_max() {
  clear_has_range_max();
  if (range_max_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = range_max_;
    range_max_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_range_max(::std::string* range_max) {
  if (range_max_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete range_max_;
  }
  if (range_max) {
    set_has_range_max();
    range_max_ = range_max;
  } else {
    clear_has_range_max();
    range_max_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.range_max)
}

// optional bool return_terms = 7;
inline bool RpbIndexReq::has_return_terms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbIndexReq::set_has_return_terms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbIndexReq::clear_has_return_terms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbIndexReq::clear_return_terms() {
  return_terms_ = false;
  clear_has_return_terms();
}
inline bool RpbIndexReq::return_terms() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.return_terms)
  return return_terms_;
}
inline void RpbIndexReq::set_return_terms(bool value) {
  set_has_return_terms();
  return_terms_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.return_terms)
}

// optional bool stream = 8;
inline bool RpbIndexReq::has_stream() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbIndexReq::set_has_stream() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbIndexReq::clear_has_stream() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbIndexReq::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool RpbIndexReq::stream() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.stream)
  return stream_;
}
inline void RpbIndexReq::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.stream)
}

// optional uint32 max_results = 9;
inline bool RpbIndexReq::has_max_results() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbIndexReq::set_has_max_results() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbIndexReq::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbIndexReq::clear_max_results() {
  max_results_ = 0u;
  clear_has_max_results();
}
inline ::google::protobuf::uint32 RpbIndexReq::max_results() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.max_results)
  return max_results_;
}
inline void RpbIndexReq::set_max_results(::google::protobuf::uint32 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.max_results)
}

// optional bytes continuation = 10;
inline bool RpbIndexReq::has_continuation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbIndexReq::set_has_continuation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbIndexReq::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbIndexReq::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexReq::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.continuation)
  return *continuation_;
}
inline void RpbIndexReq::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.continuation)
}
inline void RpbIndexReq::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.continuation)
}
inline void RpbIndexReq::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.continuation)
}
inline ::std::string* RpbIndexReq::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexReq::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.continuation)
}

// optional uint32 timeout = 11;
inline bool RpbIndexReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbIndexReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbIndexReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbIndexReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbIndexReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.timeout)
  return timeout_;
}
inline void RpbIndexReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.timeout)
}

// optional bytes type = 12;
inline bool RpbIndexReq::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RpbIndexReq::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RpbIndexReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RpbIndexReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbIndexReq::type() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.type)
  return *type_;
}
inline void RpbIndexReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.type)
}
inline void RpbIndexReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.type)
}
inline void RpbIndexReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.type)
}
inline ::std::string* RpbIndexReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.type)
  return type_;
}
inline ::std::string* RpbIndexReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.type)
}

// optional bytes term_regex = 13;
inline bool RpbIndexReq::has_term_regex() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RpbIndexReq::set_has_term_regex() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RpbIndexReq::clear_has_term_regex() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RpbIndexReq::clear_term_regex() {
  if (term_regex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_->clear();
  }
  clear_has_term_regex();
}
inline const ::std::string& RpbIndexReq::term_regex() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.term_regex)
  return *term_regex_;
}
inline void RpbIndexReq::set_term_regex(const ::std::string& value) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.term_regex)
}
inline void RpbIndexReq::set_term_regex(const char* value) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.term_regex)
}
inline void RpbIndexReq::set_term_regex(const void* value, size_t size) {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  term_regex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.term_regex)
}
inline ::std::string* RpbIndexReq::mutable_term_regex() {
  set_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    term_regex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.term_regex)
  return term_regex_;
}
inline ::std::string* RpbIndexReq::release_term_regex() {
  clear_has_term_regex();
  if (term_regex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = term_regex_;
    term_regex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_term_regex(::std::string* term_regex) {
  if (term_regex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete term_regex_;
  }
  if (term_regex) {
    set_has_term_regex();
    term_regex_ = term_regex;
  } else {
    clear_has_term_regex();
    term_regex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.term_regex)
}

// optional bool pagination_sort = 14;
inline bool RpbIndexReq::has_pagination_sort() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RpbIndexReq::set_has_pagination_sort() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RpbIndexReq::clear_has_pagination_sort() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RpbIndexReq::clear_pagination_sort() {
  pagination_sort_ = false;
  clear_has_pagination_sort();
}
inline bool RpbIndexReq::pagination_sort() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.pagination_sort)
  return pagination_sort_;
}
inline void RpbIndexReq::set_pagination_sort(bool value) {
  set_has_pagination_sort();
  pagination_sort_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.pagination_sort)
}

// optional bytes cover_context = 15;
inline bool RpbIndexReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RpbIndexReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RpbIndexReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RpbIndexReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbIndexReq::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.cover_context)
  return *cover_context_;
}
inline void RpbIndexReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexReq.cover_context)
}
inline void RpbIndexReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexReq.cover_context)
}
inline void RpbIndexReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexReq.cover_context)
}
inline ::std::string* RpbIndexReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexReq.cover_context)
  return cover_context_;
}
inline ::std::string* RpbIndexReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexReq.cover_context)
}

// optional bool return_body = 16;
inline bool RpbIndexReq::has_return_body() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RpbIndexReq::set_has_return_body() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RpbIndexReq::clear_has_return_body() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RpbIndexReq::clear_return_body() {
  return_body_ = false;
  clear_has_return_body();
}
inline bool RpbIndexReq::return_body() const {
  // @@protoc_insertion_point(field_get:RpbIndexReq.return_body)
  return return_body_;
}
inline void RpbIndexReq::set_return_body(bool value) {
  set_has_return_body();
  return_body_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexReq.return_body)
}

// -------------------------------------------------------------------

// RpbIndexResp

// repeated bytes keys = 1;
inline int RpbIndexResp::keys_size() const {
  return keys_.size();
}
inline void RpbIndexResp::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RpbIndexResp::keys(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.keys)
  return keys_.Get(index);
}
inline ::std::string* RpbIndexResp::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.keys)
  return keys_.Mutable(index);
}
inline void RpbIndexResp::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbIndexResp.keys)
  keys_.Mutable(index)->assign(value);
}
inline void RpbIndexResp::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexResp.keys)
}
inline void RpbIndexResp::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexResp.keys)
}
inline ::std::string* RpbIndexResp::add_keys() {
  return keys_.Add();
}
inline void RpbIndexResp::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbIndexResp.keys)
}
inline void RpbIndexResp::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbIndexResp.keys)
}
inline void RpbIndexResp::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbIndexResp.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbIndexResp::keys() const {
  // @@protoc_insertion_point(field_list:RpbIndexResp.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbIndexResp::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexResp.keys)
  return &keys_;
}

// repeated .RpbPair results = 2;
inline int RpbIndexResp::results_size() const {
  return results_.size();
}
inline void RpbIndexResp::clear_results() {
  results_.Clear();
}
inline const ::RpbPair& RpbIndexResp::results(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.results)
  return results_.Get(index);
}
inline ::RpbPair* RpbIndexResp::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.results)
  return results_.Mutable(index);
}
inline ::RpbPair* RpbIndexResp::add_results() {
  // @@protoc_insertion_point(field_add:RpbIndexResp.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbIndexResp::results() const {
  // @@protoc_insertion_point(field_list:RpbIndexResp.results)
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbIndexResp::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexResp.results)
  return &results_;
}

// optional bytes continuation = 3;
inline bool RpbIndexResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.continuation)
  return *continuation_;
}
inline void RpbIndexResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexResp.continuation)
}
inline void RpbIndexResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexResp.continuation)
}
inline void RpbIndexResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexResp.continuation)
}
inline ::std::string* RpbIndexResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexResp.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexResp.continuation)
}

// optional bool done = 4;
inline bool RpbIndexResp::has_done() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbIndexResp::set_has_done() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbIndexResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbIndexResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbIndexResp::done() const {
  // @@protoc_insertion_point(field_get:RpbIndexResp.done)
  return done_;
}
inline void RpbIndexResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexResp.done)
}

// -------------------------------------------------------------------

// RpbIndexBodyResp

// repeated .RpbIndexObject objects = 1;
inline int RpbIndexBodyResp::objects_size() const {
  return objects_.size();
}
inline void RpbIndexBodyResp::clear_objects() {
  objects_.Clear();
}
inline const ::RpbIndexObject& RpbIndexBodyResp::objects(int index) const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.objects)
  return objects_.Get(index);
}
inline ::RpbIndexObject* RpbIndexBodyResp::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:RpbIndexBodyResp.objects)
  return objects_.Mutable(index);
}
inline ::RpbIndexObject* RpbIndexBodyResp::add_objects() {
  // @@protoc_insertion_point(field_add:RpbIndexBodyResp.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
RpbIndexBodyResp::objects() const {
  // @@protoc_insertion_point(field_list:RpbIndexBodyResp.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
RpbIndexBodyResp::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:RpbIndexBodyResp.objects)
  return &objects_;
}

// optional bytes continuation = 2;
inline bool RpbIndexBodyResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexBodyResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexBodyResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexBodyResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbIndexBodyResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.continuation)
  return *continuation_;
}
inline void RpbIndexBodyResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexBodyResp.continuation)
}
inline void RpbIndexBodyResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexBodyResp.continuation)
}
inline void RpbIndexBodyResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexBodyResp.continuation)
}
inline ::std::string* RpbIndexBodyResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexBodyResp.continuation)
  return continuation_;
}
inline ::std::string* RpbIndexBodyResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexBodyResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexBodyResp.continuation)
}

// optional bool done = 3;
inline bool RpbIndexBodyResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbIndexBodyResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbIndexBodyResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbIndexBodyResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbIndexBodyResp::done() const {
  // @@protoc_insertion_point(field_get:RpbIndexBodyResp.done)
  return done_;
}
inline void RpbIndexBodyResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbIndexBodyResp.done)
}

// -------------------------------------------------------------------

// RpbCSBucketReq

// required bytes bucket = 1;
inline bool RpbCSBucketReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCSBucketReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCSBucketReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCSBucketReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCSBucketReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.bucket)
  return *bucket_;
}
inline void RpbCSBucketReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.bucket)
}
inline void RpbCSBucketReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.bucket)
}
inline void RpbCSBucketReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.bucket)
}
inline ::std::string* RpbCSBucketReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCSBucketReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.bucket)
}

// required bytes start_key = 2;
inline bool RpbCSBucketReq::has_start_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCSBucketReq::set_has_start_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCSBucketReq::clear_has_start_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCSBucketReq::clear_start_key() {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_->clear();
  }
  clear_has_start_key();
}
inline const ::std::string& RpbCSBucketReq::start_key() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.start_key)
  return *start_key_;
}
inline void RpbCSBucketReq::set_start_key(const ::std::string& value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.start_key)
}
inline void RpbCSBucketReq::set_start_key(const char* value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.start_key)
}
inline void RpbCSBucketReq::set_start_key(const void* value, size_t size) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.start_key)
}
inline ::std::string* RpbCSBucketReq::mutable_start_key() {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.start_key)
  return start_key_;
}
inline ::std::string* RpbCSBucketReq::release_start_key() {
  clear_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_key_;
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_start_key(::std::string* start_key) {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_key_;
  }
  if (start_key) {
    set_has_start_key();
    start_key_ = start_key;
  } else {
    clear_has_start_key();
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.start_key)
}

// optional bytes end_key = 3;
inline bool RpbCSBucketReq::has_end_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCSBucketReq::set_has_end_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCSBucketReq::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCSBucketReq::clear_end_key() {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_->clear();
  }
  clear_has_end_key();
}
inline const ::std::string& RpbCSBucketReq::end_key() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.end_key)
  return *end_key_;
}
inline void RpbCSBucketReq::set_end_key(const ::std::string& value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.end_key)
}
inline void RpbCSBucketReq::set_end_key(const char* value) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.end_key)
}
inline void RpbCSBucketReq::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  end_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.end_key)
}
inline ::std::string* RpbCSBucketReq::mutable_end_key() {
  set_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.end_key)
  return end_key_;
}
inline ::std::string* RpbCSBucketReq::release_end_key() {
  clear_has_end_key();
  if (end_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_key_;
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_end_key(::std::string* end_key) {
  if (end_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_key_;
  }
  if (end_key) {
    set_has_end_key();
    end_key_ = end_key;
  } else {
    clear_has_end_key();
    end_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.end_key)
}

// optional bool start_incl = 4 [default = true];
inline bool RpbCSBucketReq::has_start_incl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCSBucketReq::set_has_start_incl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCSBucketReq::clear_has_start_incl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCSBucketReq::clear_start_incl() {
  start_incl_ = true;
  clear_has_start_incl();
}
inline bool RpbCSBucketReq::start_incl() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.start_incl)
  return start_incl_;
}
inline void RpbCSBucketReq::set_start_incl(bool value) {
  set_has_start_incl();
  start_incl_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.start_incl)
}

// optional bool end_incl = 5 [default = false];
inline bool RpbCSBucketReq::has_end_incl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCSBucketReq::set_has_end_incl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCSBucketReq::clear_has_end_incl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCSBucketReq::clear_end_incl() {
  end_incl_ = false;
  clear_has_end_incl();
}
inline bool RpbCSBucketReq::end_incl() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.end_incl)
  return end_incl_;
}
inline void RpbCSBucketReq::set_end_incl(bool value) {
  set_has_end_incl();
  end_incl_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.end_incl)
}

// optional bytes continuation = 6;
inline bool RpbCSBucketReq::has_continuation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCSBucketReq::set_has_continuation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCSBucketReq::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCSBucketReq::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbCSBucketReq::continuation() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.continuation)
  return *continuation_;
}
inline void RpbCSBucketReq::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.continuation)
}
inline void RpbCSBucketReq::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.continuation)
}
inline void RpbCSBucketReq::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.continuation)
}
inline ::std::string* RpbCSBucketReq::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.continuation)
  return continuation_;
}
inline ::std::string* RpbCSBucketReq::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.continuation)
}

// optional uint32 max_results = 7;
inline bool RpbCSBucketReq::has_max_results() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbCSBucketReq::set_has_max_results() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbCSBucketReq::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbCSBucketReq::clear_max_results() {
  max_results_ = 0u;
  clear_has_max_results();
}
inline ::google::protobuf::uint32 RpbCSBucketReq::max_results() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.max_results)
  return max_results_;
}
inline void RpbCSBucketReq::set_max_results(::google::protobuf::uint32 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.max_results)
}

// optional uint32 timeout = 8;
inline bool RpbCSBucketReq::has_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbCSBucketReq::set_has_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbCSBucketReq::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbCSBucketReq::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 RpbCSBucketReq::timeout() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.timeout)
  return timeout_;
}
inline void RpbCSBucketReq::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.timeout)
}

// optional bytes type = 9;
inline bool RpbCSBucketReq::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RpbCSBucketReq::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RpbCSBucketReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RpbCSBucketReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbCSBucketReq::type() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.type)
  return *type_;
}
inline void RpbCSBucketReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.type)
}
inline void RpbCSBucketReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.type)
}
inline void RpbCSBucketReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.type)
}
inline ::std::string* RpbCSBucketReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.type)
  return type_;
}
inline ::std::string* RpbCSBucketReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.type)
}

// optional bytes cover_context = 10;
inline bool RpbCSBucketReq::has_cover_context() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RpbCSBucketReq::set_has_cover_context() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RpbCSBucketReq::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RpbCSBucketReq::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbCSBucketReq::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketReq.cover_context)
  return *cover_context_;
}
inline void RpbCSBucketReq::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketReq.cover_context)
}
inline void RpbCSBucketReq::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketReq.cover_context)
}
inline void RpbCSBucketReq::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketReq.cover_context)
}
inline ::std::string* RpbCSBucketReq::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketReq.cover_context)
  return cover_context_;
}
inline ::std::string* RpbCSBucketReq::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketReq::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketReq.cover_context)
}

// -------------------------------------------------------------------

// RpbCSBucketResp

// repeated .RpbIndexObject objects = 1;
inline int RpbCSBucketResp::objects_size() const {
  return objects_.size();
}
inline void RpbCSBucketResp::clear_objects() {
  objects_.Clear();
}
inline const ::RpbIndexObject& RpbCSBucketResp::objects(int index) const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.objects)
  return objects_.Get(index);
}
inline ::RpbIndexObject* RpbCSBucketResp::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCSBucketResp.objects)
  return objects_.Mutable(index);
}
inline ::RpbIndexObject* RpbCSBucketResp::add_objects() {
  // @@protoc_insertion_point(field_add:RpbCSBucketResp.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >&
RpbCSBucketResp::objects() const {
  // @@protoc_insertion_point(field_list:RpbCSBucketResp.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbIndexObject >*
RpbCSBucketResp::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:RpbCSBucketResp.objects)
  return &objects_;
}

// optional bytes continuation = 2;
inline bool RpbCSBucketResp::has_continuation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCSBucketResp::set_has_continuation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCSBucketResp::clear_has_continuation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCSBucketResp::clear_continuation() {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_->clear();
  }
  clear_has_continuation();
}
inline const ::std::string& RpbCSBucketResp::continuation() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.continuation)
  return *continuation_;
}
inline void RpbCSBucketResp::set_continuation(const ::std::string& value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCSBucketResp.continuation)
}
inline void RpbCSBucketResp::set_continuation(const char* value) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCSBucketResp.continuation)
}
inline void RpbCSBucketResp::set_continuation(const void* value, size_t size) {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  continuation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCSBucketResp.continuation)
}
inline ::std::string* RpbCSBucketResp::mutable_continuation() {
  set_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    continuation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCSBucketResp.continuation)
  return continuation_;
}
inline ::std::string* RpbCSBucketResp::release_continuation() {
  clear_has_continuation();
  if (continuation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = continuation_;
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCSBucketResp::set_allocated_continuation(::std::string* continuation) {
  if (continuation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete continuation_;
  }
  if (continuation) {
    set_has_continuation();
    continuation_ = continuation;
  } else {
    clear_has_continuation();
    continuation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCSBucketResp.continuation)
}

// optional bool done = 3;
inline bool RpbCSBucketResp::has_done() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCSBucketResp::set_has_done() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCSBucketResp::clear_has_done() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCSBucketResp::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool RpbCSBucketResp::done() const {
  // @@protoc_insertion_point(field_get:RpbCSBucketResp.done)
  return done_;
}
inline void RpbCSBucketResp::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:RpbCSBucketResp.done)
}

// -------------------------------------------------------------------

// RpbIndexObject

// required bytes key = 1;
inline bool RpbIndexObject::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbIndexObject::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbIndexObject::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbIndexObject::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbIndexObject::key() const {
  // @@protoc_insertion_point(field_get:RpbIndexObject.key)
  return *key_;
}
inline void RpbIndexObject::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbIndexObject.key)
}
inline void RpbIndexObject::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbIndexObject.key)
}
inline void RpbIndexObject::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbIndexObject.key)
}
inline ::std::string* RpbIndexObject::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbIndexObject.key)
  return key_;
}
inline ::std::string* RpbIndexObject::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbIndexObject::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexObject.key)
}

// required .RpbGetResp object = 2;
inline bool RpbIndexObject::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbIndexObject::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbIndexObject::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbIndexObject::clear_object() {
  if (object_ != NULL) object_->::RpbGetResp::Clear();
  clear_has_object();
}
inline const ::RpbGetResp& RpbIndexObject::object() const {
  // @@protoc_insertion_point(field_get:RpbIndexObject.object)
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::RpbGetResp* RpbIndexObject::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::RpbGetResp;
  // @@protoc_insertion_point(field_mutable:RpbIndexObject.object)
  return object_;
}
inline ::RpbGetResp* RpbIndexObject::release_object() {
  clear_has_object();
  ::RpbGetResp* temp = object_;
  object_ = NULL;
  return temp;
}
inline void RpbIndexObject::set_allocated_object(::RpbGetResp* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
  // @@protoc_insertion_point(field_set_allocated:RpbIndexObject.object)
}

// -------------------------------------------------------------------

// RpbContent

// required bytes value = 1;
inline bool RpbContent::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbContent::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbContent::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbContent::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RpbContent::value() const {
  // @@protoc_insertion_point(field_get:RpbContent.value)
  return *value_;
}
inline void RpbContent::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.value)
}
inline void RpbContent::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.value)
}
inline void RpbContent::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.value)
}
inline ::std::string* RpbContent::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.value)
  return value_;
}
inline ::std::string* RpbContent::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.value)
}

// optional bytes content_type = 2;
inline bool RpbContent::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbContent::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbContent::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbContent::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& RpbContent::content_type() const {
  // @@protoc_insertion_point(field_get:RpbContent.content_type)
  return *content_type_;
}
inline void RpbContent::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.content_type)
}
inline void RpbContent::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.content_type)
}
inline void RpbContent::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.content_type)
}
inline ::std::string* RpbContent::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.content_type)
  return content_type_;
}
inline ::std::string* RpbContent::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.content_type)
}

// optional bytes charset = 3;
inline bool RpbContent::has_charset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbContent::set_has_charset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbContent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbContent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& RpbContent::charset() const {
  // @@protoc_insertion_point(field_get:RpbContent.charset)
  return *charset_;
}
inline void RpbContent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.charset)
}
inline void RpbContent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.charset)
}
inline void RpbContent::set_charset(const void* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.charset)
}
inline ::std::string* RpbContent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.charset)
  return charset_;
}
inline ::std::string* RpbContent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.charset)
}

// optional bytes content_encoding = 4;
inline bool RpbContent::has_content_encoding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbContent::set_has_content_encoding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbContent::clear_has_content_encoding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbContent::clear_content_encoding() {
  if (content_encoding_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_->clear();
  }
  clear_has_content_encoding();
}
inline const ::std::string& RpbContent::content_encoding() const {
  // @@protoc_insertion_point(field_get:RpbContent.content_encoding)
  return *content_encoding_;
}
inline void RpbContent::set_content_encoding(const ::std::string& value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.content_encoding)
}
inline void RpbContent::set_content_encoding(const char* value) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.content_encoding)
}
inline void RpbContent::set_content_encoding(const void* value, size_t size) {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  content_encoding_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.content_encoding)
}
inline ::std::string* RpbContent::mutable_content_encoding() {
  set_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_encoding_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.content_encoding)
  return content_encoding_;
}
inline ::std::string* RpbContent::release_content_encoding() {
  clear_has_content_encoding();
  if (content_encoding_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_encoding_;
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_content_encoding(::std::string* content_encoding) {
  if (content_encoding_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_encoding_;
  }
  if (content_encoding) {
    set_has_content_encoding();
    content_encoding_ = content_encoding;
  } else {
    clear_has_content_encoding();
    content_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.content_encoding)
}

// optional bytes vtag = 5;
inline bool RpbContent::has_vtag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbContent::set_has_vtag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbContent::clear_has_vtag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbContent::clear_vtag() {
  if (vtag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_->clear();
  }
  clear_has_vtag();
}
inline const ::std::string& RpbContent::vtag() const {
  // @@protoc_insertion_point(field_get:RpbContent.vtag)
  return *vtag_;
}
inline void RpbContent::set_vtag(const ::std::string& value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
  // @@protoc_insertion_point(field_set:RpbContent.vtag)
}
inline void RpbContent::set_vtag(const char* value) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbContent.vtag)
}
inline void RpbContent::set_vtag(const void* value, size_t size) {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  vtag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbContent.vtag)
}
inline ::std::string* RpbContent::mutable_vtag() {
  set_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vtag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbContent.vtag)
  return vtag_;
}
inline ::std::string* RpbContent::release_vtag() {
  clear_has_vtag();
  if (vtag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vtag_;
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbContent::set_allocated_vtag(::std::string* vtag) {
  if (vtag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vtag_;
  }
  if (vtag) {
    set_has_vtag();
    vtag_ = vtag;
  } else {
    clear_has_vtag();
    vtag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbContent.vtag)
}

// repeated .RpbLink links = 6;
inline int RpbContent::links_size() const {
  return links_.size();
}
inline void RpbContent::clear_links() {
  links_.Clear();
}
inline const ::RpbLink& RpbContent::links(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.links)
  return links_.Get(index);
}
inline ::RpbLink* RpbContent::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.links)
  return links_.Mutable(index);
}
inline ::RpbLink* RpbContent::add_links() {
  // @@protoc_insertion_point(field_add:RpbContent.links)
  return links_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbLink >&
RpbContent::links() const {
  // @@protoc_insertion_point(field_list:RpbContent.links)
  return links_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbLink >*
RpbContent::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.links)
  return &links_;
}

// optional uint32 last_mod = 7;
inline bool RpbContent::has_last_mod() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbContent::set_has_last_mod() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbContent::clear_has_last_mod() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbContent::clear_last_mod() {
  last_mod_ = 0u;
  clear_has_last_mod();
}
inline ::google::protobuf::uint32 RpbContent::last_mod() const {
  // @@protoc_insertion_point(field_get:RpbContent.last_mod)
  return last_mod_;
}
inline void RpbContent::set_last_mod(::google::protobuf::uint32 value) {
  set_has_last_mod();
  last_mod_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.last_mod)
}

// optional uint32 last_mod_usecs = 8;
inline bool RpbContent::has_last_mod_usecs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpbContent::set_has_last_mod_usecs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpbContent::clear_has_last_mod_usecs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpbContent::clear_last_mod_usecs() {
  last_mod_usecs_ = 0u;
  clear_has_last_mod_usecs();
}
inline ::google::protobuf::uint32 RpbContent::last_mod_usecs() const {
  // @@protoc_insertion_point(field_get:RpbContent.last_mod_usecs)
  return last_mod_usecs_;
}
inline void RpbContent::set_last_mod_usecs(::google::protobuf::uint32 value) {
  set_has_last_mod_usecs();
  last_mod_usecs_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.last_mod_usecs)
}

// repeated .RpbPair usermeta = 9;
inline int RpbContent::usermeta_size() const {
  return usermeta_.size();
}
inline void RpbContent::clear_usermeta() {
  usermeta_.Clear();
}
inline const ::RpbPair& RpbContent::usermeta(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.usermeta)
  return usermeta_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_usermeta(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.usermeta)
  return usermeta_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_usermeta() {
  // @@protoc_insertion_point(field_add:RpbContent.usermeta)
  return usermeta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::usermeta() const {
  // @@protoc_insertion_point(field_list:RpbContent.usermeta)
  return usermeta_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_usermeta() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.usermeta)
  return &usermeta_;
}

// repeated .RpbPair indexes = 10;
inline int RpbContent::indexes_size() const {
  return indexes_.size();
}
inline void RpbContent::clear_indexes() {
  indexes_.Clear();
}
inline const ::RpbPair& RpbContent::indexes(int index) const {
  // @@protoc_insertion_point(field_get:RpbContent.indexes)
  return indexes_.Get(index);
}
inline ::RpbPair* RpbContent::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:RpbContent.indexes)
  return indexes_.Mutable(index);
}
inline ::RpbPair* RpbContent::add_indexes() {
  // @@protoc_insertion_point(field_add:RpbContent.indexes)
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbPair >&
RpbContent::indexes() const {
  // @@protoc_insertion_point(field_list:RpbContent.indexes)
  return indexes_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbPair >*
RpbContent::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:RpbContent.indexes)
  return &indexes_;
}

// optional bool deleted = 11;
inline bool RpbContent::has_deleted() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RpbContent::set_has_deleted() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RpbContent::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RpbContent::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool RpbContent::deleted() const {
  // @@protoc_insertion_point(field_get:RpbContent.deleted)
  return deleted_;
}
inline void RpbContent::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
  // @@protoc_insertion_point(field_set:RpbContent.deleted)
}

// -------------------------------------------------------------------

// RpbLink

// optional bytes bucket = 1;
inline bool RpbLink::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbLink::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbLink::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbLink::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbLink::bucket() const {
  // @@protoc_insertion_point(field_get:RpbLink.bucket)
  return *bucket_;
}
inline void RpbLink::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.bucket)
}
inline void RpbLink::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.bucket)
}
inline void RpbLink::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.bucket)
}
inline ::std::string* RpbLink::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.bucket)
  return bucket_;
}
inline ::std::string* RpbLink::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.bucket)
}

// optional bytes key = 2;
inline bool RpbLink::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbLink::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbLink::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbLink::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbLink::key() const {
  // @@protoc_insertion_point(field_get:RpbLink.key)
  return *key_;
}
inline void RpbLink::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.key)
}
inline void RpbLink::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.key)
}
inline void RpbLink::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.key)
}
inline ::std::string* RpbLink::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.key)
  return key_;
}
inline ::std::string* RpbLink::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.key)
}

// optional bytes tag = 3;
inline bool RpbLink::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbLink::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbLink::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbLink::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& RpbLink::tag() const {
  // @@protoc_insertion_point(field_get:RpbLink.tag)
  return *tag_;
}
inline void RpbLink::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:RpbLink.tag)
}
inline void RpbLink::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbLink.tag)
}
inline void RpbLink::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbLink.tag)
}
inline ::std::string* RpbLink::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbLink.tag)
  return tag_;
}
inline ::std::string* RpbLink::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbLink::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbLink.tag)
}

// -------------------------------------------------------------------

// RpbCounterUpdateReq

// required bytes bucket = 1;
inline bool RpbCounterUpdateReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterUpdateReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterUpdateReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterUpdateReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCounterUpdateReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.bucket)
  return *bucket_;
}
inline void RpbCounterUpdateReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.bucket)
}
inline void RpbCounterUpdateReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterUpdateReq.bucket)
}
inline void RpbCounterUpdateReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterUpdateReq.bucket)
}
inline ::std::string* RpbCounterUpdateReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterUpdateReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCounterUpdateReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterUpdateReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterUpdateReq.bucket)
}

// required bytes key = 2;
inline bool RpbCounterUpdateReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCounterUpdateReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCounterUpdateReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCounterUpdateReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbCounterUpdateReq::key() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.key)
  return *key_;
}
inline void RpbCounterUpdateReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.key)
}
inline void RpbCounterUpdateReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterUpdateReq.key)
}
inline void RpbCounterUpdateReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterUpdateReq.key)
}
inline ::std::string* RpbCounterUpdateReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterUpdateReq.key)
  return key_;
}
inline ::std::string* RpbCounterUpdateReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterUpdateReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterUpdateReq.key)
}

// required sint64 amount = 3;
inline bool RpbCounterUpdateReq::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCounterUpdateReq::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCounterUpdateReq::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCounterUpdateReq::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 RpbCounterUpdateReq::amount() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.amount)
  return amount_;
}
inline void RpbCounterUpdateReq::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.amount)
}

// optional uint32 w = 4;
inline bool RpbCounterUpdateReq::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCounterUpdateReq::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCounterUpdateReq::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCounterUpdateReq::clear_w() {
  w_ = 0u;
  clear_has_w();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::w() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.w)
  return w_;
}
inline void RpbCounterUpdateReq::set_w(::google::protobuf::uint32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.w)
}

// optional uint32 dw = 5;
inline bool RpbCounterUpdateReq::has_dw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCounterUpdateReq::set_has_dw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCounterUpdateReq::clear_has_dw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCounterUpdateReq::clear_dw() {
  dw_ = 0u;
  clear_has_dw();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::dw() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.dw)
  return dw_;
}
inline void RpbCounterUpdateReq::set_dw(::google::protobuf::uint32 value) {
  set_has_dw();
  dw_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.dw)
}

// optional uint32 pw = 6;
inline bool RpbCounterUpdateReq::has_pw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCounterUpdateReq::set_has_pw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCounterUpdateReq::clear_has_pw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCounterUpdateReq::clear_pw() {
  pw_ = 0u;
  clear_has_pw();
}
inline ::google::protobuf::uint32 RpbCounterUpdateReq::pw() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.pw)
  return pw_;
}
inline void RpbCounterUpdateReq::set_pw(::google::protobuf::uint32 value) {
  set_has_pw();
  pw_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.pw)
}

// optional bool returnvalue = 7;
inline bool RpbCounterUpdateReq::has_returnvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpbCounterUpdateReq::set_has_returnvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpbCounterUpdateReq::clear_has_returnvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpbCounterUpdateReq::clear_returnvalue() {
  returnvalue_ = false;
  clear_has_returnvalue();
}
inline bool RpbCounterUpdateReq::returnvalue() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateReq.returnvalue)
  return returnvalue_;
}
inline void RpbCounterUpdateReq::set_returnvalue(bool value) {
  set_has_returnvalue();
  returnvalue_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateReq.returnvalue)
}

// -------------------------------------------------------------------

// RpbCounterUpdateResp

// optional sint64 value = 1;
inline bool RpbCounterUpdateResp::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterUpdateResp::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterUpdateResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterUpdateResp::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 RpbCounterUpdateResp::value() const {
  // @@protoc_insertion_point(field_get:RpbCounterUpdateResp.value)
  return value_;
}
inline void RpbCounterUpdateResp::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterUpdateResp.value)
}

// -------------------------------------------------------------------

// RpbCounterGetReq

// required bytes bucket = 1;
inline bool RpbCounterGetReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterGetReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterGetReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterGetReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCounterGetReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.bucket)
  return *bucket_;
}
inline void RpbCounterGetReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.bucket)
}
inline void RpbCounterGetReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterGetReq.bucket)
}
inline void RpbCounterGetReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterGetReq.bucket)
}
inline ::std::string* RpbCounterGetReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterGetReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCounterGetReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterGetReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterGetReq.bucket)
}

// required bytes key = 2;
inline bool RpbCounterGetReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCounterGetReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCounterGetReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCounterGetReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbCounterGetReq::key() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.key)
  return *key_;
}
inline void RpbCounterGetReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.key)
}
inline void RpbCounterGetReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCounterGetReq.key)
}
inline void RpbCounterGetReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCounterGetReq.key)
}
inline ::std::string* RpbCounterGetReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCounterGetReq.key)
  return key_;
}
inline ::std::string* RpbCounterGetReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCounterGetReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCounterGetReq.key)
}

// optional uint32 r = 3;
inline bool RpbCounterGetReq::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCounterGetReq::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCounterGetReq::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCounterGetReq::clear_r() {
  r_ = 0u;
  clear_has_r();
}
inline ::google::protobuf::uint32 RpbCounterGetReq::r() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.r)
  return r_;
}
inline void RpbCounterGetReq::set_r(::google::protobuf::uint32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.r)
}

// optional uint32 pr = 4;
inline bool RpbCounterGetReq::has_pr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCounterGetReq::set_has_pr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCounterGetReq::clear_has_pr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCounterGetReq::clear_pr() {
  pr_ = 0u;
  clear_has_pr();
}
inline ::google::protobuf::uint32 RpbCounterGetReq::pr() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.pr)
  return pr_;
}
inline void RpbCounterGetReq::set_pr(::google::protobuf::uint32 value) {
  set_has_pr();
  pr_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.pr)
}

// optional bool basic_quorum = 5;
inline bool RpbCounterGetReq::has_basic_quorum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpbCounterGetReq::set_has_basic_quorum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpbCounterGetReq::clear_has_basic_quorum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpbCounterGetReq::clear_basic_quorum() {
  basic_quorum_ = false;
  clear_has_basic_quorum();
}
inline bool RpbCounterGetReq::basic_quorum() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.basic_quorum)
  return basic_quorum_;
}
inline void RpbCounterGetReq::set_basic_quorum(bool value) {
  set_has_basic_quorum();
  basic_quorum_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.basic_quorum)
}

// optional bool notfound_ok = 6;
inline bool RpbCounterGetReq::has_notfound_ok() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpbCounterGetReq::set_has_notfound_ok() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpbCounterGetReq::clear_has_notfound_ok() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpbCounterGetReq::clear_notfound_ok() {
  notfound_ok_ = false;
  clear_has_notfound_ok();
}
inline bool RpbCounterGetReq::notfound_ok() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetReq.notfound_ok)
  return notfound_ok_;
}
inline void RpbCounterGetReq::set_notfound_ok(bool value) {
  set_has_notfound_ok();
  notfound_ok_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetReq.notfound_ok)
}

// -------------------------------------------------------------------

// RpbCounterGetResp

// optional sint64 value = 1;
inline bool RpbCounterGetResp::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCounterGetResp::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCounterGetResp::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCounterGetResp::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 RpbCounterGetResp::value() const {
  // @@protoc_insertion_point(field_get:RpbCounterGetResp.value)
  return value_;
}
inline void RpbCounterGetResp::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:RpbCounterGetResp.value)
}

// -------------------------------------------------------------------

// RpbGetBucketKeyPreflistReq

// required bytes bucket = 1;
inline bool RpbGetBucketKeyPreflistReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbGetBucketKeyPreflistReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.bucket)
  return *bucket_;
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.bucket)
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.bucket)
}
inline void RpbGetBucketKeyPreflistReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.bucket)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.bucket)
  return bucket_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.bucket)
}

// required bytes key = 2;
inline bool RpbGetBucketKeyPreflistReq::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbGetBucketKeyPreflistReq::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::key() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.key)
  return *key_;
}
inline void RpbGetBucketKeyPreflistReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.key)
}
inline void RpbGetBucketKeyPreflistReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.key)
}
inline void RpbGetBucketKeyPreflistReq::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.key)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.key)
  return key_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.key)
}

// optional bytes type = 3;
inline bool RpbGetBucketKeyPreflistReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbGetBucketKeyPreflistReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbGetBucketKeyPreflistReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbGetBucketKeyPreflistReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbGetBucketKeyPreflistReq::type() const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistReq.type)
  return *type_;
}
inline void RpbGetBucketKeyPreflistReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbGetBucketKeyPreflistReq.type)
}
inline void RpbGetBucketKeyPreflistReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbGetBucketKeyPreflistReq.type)
}
inline void RpbGetBucketKeyPreflistReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbGetBucketKeyPreflistReq.type)
}
inline ::std::string* RpbGetBucketKeyPreflistReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistReq.type)
  return type_;
}
inline ::std::string* RpbGetBucketKeyPreflistReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbGetBucketKeyPreflistReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbGetBucketKeyPreflistReq.type)
}

// -------------------------------------------------------------------

// RpbGetBucketKeyPreflistResp

// repeated .RpbBucketKeyPreflistItem preflist = 1;
inline int RpbGetBucketKeyPreflistResp::preflist_size() const {
  return preflist_.size();
}
inline void RpbGetBucketKeyPreflistResp::clear_preflist() {
  preflist_.Clear();
}
inline const ::RpbBucketKeyPreflistItem& RpbGetBucketKeyPreflistResp::preflist(int index) const {
  // @@protoc_insertion_point(field_get:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Get(index);
}
inline ::RpbBucketKeyPreflistItem* RpbGetBucketKeyPreflistResp::mutable_preflist(int index) {
  // @@protoc_insertion_point(field_mutable:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Mutable(index);
}
inline ::RpbBucketKeyPreflistItem* RpbGetBucketKeyPreflistResp::add_preflist() {
  // @@protoc_insertion_point(field_add:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >&
RpbGetBucketKeyPreflistResp::preflist() const {
  // @@protoc_insertion_point(field_list:RpbGetBucketKeyPreflistResp.preflist)
  return preflist_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbBucketKeyPreflistItem >*
RpbGetBucketKeyPreflistResp::mutable_preflist() {
  // @@protoc_insertion_point(field_mutable_list:RpbGetBucketKeyPreflistResp.preflist)
  return &preflist_;
}

// -------------------------------------------------------------------

// RpbBucketKeyPreflistItem

// required int64 partition = 1;
inline bool RpbBucketKeyPreflistItem::has_partition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_partition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbBucketKeyPreflistItem::clear_has_partition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbBucketKeyPreflistItem::clear_partition() {
  partition_ = GOOGLE_LONGLONG(0);
  clear_has_partition();
}
inline ::google::protobuf::int64 RpbBucketKeyPreflistItem::partition() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.partition)
  return partition_;
}
inline void RpbBucketKeyPreflistItem::set_partition(::google::protobuf::int64 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.partition)
}

// required bytes node = 2;
inline bool RpbBucketKeyPreflistItem::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbBucketKeyPreflistItem::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbBucketKeyPreflistItem::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& RpbBucketKeyPreflistItem::node() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.node)
  return *node_;
}
inline void RpbBucketKeyPreflistItem::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.node)
}
inline void RpbBucketKeyPreflistItem::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbBucketKeyPreflistItem.node)
}
inline void RpbBucketKeyPreflistItem::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbBucketKeyPreflistItem.node)
}
inline ::std::string* RpbBucketKeyPreflistItem::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbBucketKeyPreflistItem.node)
  return node_;
}
inline ::std::string* RpbBucketKeyPreflistItem::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbBucketKeyPreflistItem::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbBucketKeyPreflistItem.node)
}

// required bool primary = 3;
inline bool RpbBucketKeyPreflistItem::has_primary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbBucketKeyPreflistItem::set_has_primary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbBucketKeyPreflistItem::clear_has_primary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbBucketKeyPreflistItem::clear_primary() {
  primary_ = false;
  clear_has_primary();
}
inline bool RpbBucketKeyPreflistItem::primary() const {
  // @@protoc_insertion_point(field_get:RpbBucketKeyPreflistItem.primary)
  return primary_;
}
inline void RpbBucketKeyPreflistItem::set_primary(bool value) {
  set_has_primary();
  primary_ = value;
  // @@protoc_insertion_point(field_set:RpbBucketKeyPreflistItem.primary)
}

// -------------------------------------------------------------------

// RpbCoverageReq

// optional bytes type = 1;
inline bool RpbCoverageReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCoverageReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCoverageReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCoverageReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& RpbCoverageReq::type() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.type)
  return *type_;
}
inline void RpbCoverageReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.type)
}
inline void RpbCoverageReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.type)
}
inline void RpbCoverageReq::set_type(const void* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.type)
}
inline ::std::string* RpbCoverageReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.type)
  return type_;
}
inline ::std::string* RpbCoverageReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.type)
}

// required bytes bucket = 2;
inline bool RpbCoverageReq::has_bucket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCoverageReq::set_has_bucket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCoverageReq::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCoverageReq::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& RpbCoverageReq::bucket() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.bucket)
  return *bucket_;
}
inline void RpbCoverageReq::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.bucket)
}
inline void RpbCoverageReq::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.bucket)
}
inline void RpbCoverageReq::set_bucket(const void* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.bucket)
}
inline ::std::string* RpbCoverageReq::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bucket_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.bucket)
  return bucket_;
}
inline ::std::string* RpbCoverageReq::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.bucket)
}

// optional uint32 min_partitions = 3;
inline bool RpbCoverageReq::has_min_partitions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCoverageReq::set_has_min_partitions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCoverageReq::clear_has_min_partitions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCoverageReq::clear_min_partitions() {
  min_partitions_ = 0u;
  clear_has_min_partitions();
}
inline ::google::protobuf::uint32 RpbCoverageReq::min_partitions() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.min_partitions)
  return min_partitions_;
}
inline void RpbCoverageReq::set_min_partitions(::google::protobuf::uint32 value) {
  set_has_min_partitions();
  min_partitions_ = value;
  // @@protoc_insertion_point(field_set:RpbCoverageReq.min_partitions)
}

// optional bytes replace_cover = 4;
inline bool RpbCoverageReq::has_replace_cover() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCoverageReq::set_has_replace_cover() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCoverageReq::clear_has_replace_cover() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCoverageReq::clear_replace_cover() {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_->clear();
  }
  clear_has_replace_cover();
}
inline const ::std::string& RpbCoverageReq::replace_cover() const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.replace_cover)
  return *replace_cover_;
}
inline void RpbCoverageReq::set_replace_cover(const ::std::string& value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageReq.replace_cover)
}
inline void RpbCoverageReq::set_replace_cover(const char* value) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.replace_cover)
}
inline void RpbCoverageReq::set_replace_cover(const void* value, size_t size) {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  replace_cover_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.replace_cover)
}
inline ::std::string* RpbCoverageReq::mutable_replace_cover() {
  set_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    replace_cover_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.replace_cover)
  return replace_cover_;
}
inline ::std::string* RpbCoverageReq::release_replace_cover() {
  clear_has_replace_cover();
  if (replace_cover_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = replace_cover_;
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageReq::set_allocated_replace_cover(::std::string* replace_cover) {
  if (replace_cover_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete replace_cover_;
  }
  if (replace_cover) {
    set_has_replace_cover();
    replace_cover_ = replace_cover;
  } else {
    clear_has_replace_cover();
    replace_cover_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageReq.replace_cover)
}

// repeated bytes unavailable_cover = 5;
inline int RpbCoverageReq::unavailable_cover_size() const {
  return unavailable_cover_.size();
}
inline void RpbCoverageReq::clear_unavailable_cover() {
  unavailable_cover_.Clear();
}
inline const ::std::string& RpbCoverageReq::unavailable_cover(int index) const {
  // @@protoc_insertion_point(field_get:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_.Get(index);
}
inline ::std::string* RpbCoverageReq::mutable_unavailable_cover(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_.Mutable(index);
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RpbCoverageReq.unavailable_cover)
  unavailable_cover_.Mutable(index)->assign(value);
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const char* value) {
  unavailable_cover_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::set_unavailable_cover(int index, const void* value, size_t size) {
  unavailable_cover_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageReq.unavailable_cover)
}
inline ::std::string* RpbCoverageReq::add_unavailable_cover() {
  return unavailable_cover_.Add();
}
inline void RpbCoverageReq::add_unavailable_cover(const ::std::string& value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::add_unavailable_cover(const char* value) {
  unavailable_cover_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RpbCoverageReq.unavailable_cover)
}
inline void RpbCoverageReq::add_unavailable_cover(const void* value, size_t size) {
  unavailable_cover_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RpbCoverageReq.unavailable_cover)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RpbCoverageReq::unavailable_cover() const {
  // @@protoc_insertion_point(field_list:RpbCoverageReq.unavailable_cover)
  return unavailable_cover_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RpbCoverageReq::mutable_unavailable_cover() {
  // @@protoc_insertion_point(field_mutable_list:RpbCoverageReq.unavailable_cover)
  return &unavailable_cover_;
}

// -------------------------------------------------------------------

// RpbCoverageResp

// repeated .RpbCoverageEntry entries = 1;
inline int RpbCoverageResp::entries_size() const {
  return entries_.size();
}
inline void RpbCoverageResp::clear_entries() {
  entries_.Clear();
}
inline const ::RpbCoverageEntry& RpbCoverageResp::entries(int index) const {
  // @@protoc_insertion_point(field_get:RpbCoverageResp.entries)
  return entries_.Get(index);
}
inline ::RpbCoverageEntry* RpbCoverageResp::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:RpbCoverageResp.entries)
  return entries_.Mutable(index);
}
inline ::RpbCoverageEntry* RpbCoverageResp::add_entries() {
  // @@protoc_insertion_point(field_add:RpbCoverageResp.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >&
RpbCoverageResp::entries() const {
  // @@protoc_insertion_point(field_list:RpbCoverageResp.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::RpbCoverageEntry >*
RpbCoverageResp::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:RpbCoverageResp.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// RpbCoverageEntry

// required bytes ip = 1;
inline bool RpbCoverageEntry::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpbCoverageEntry::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpbCoverageEntry::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpbCoverageEntry::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RpbCoverageEntry::ip() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.ip)
  return *ip_;
}
inline void RpbCoverageEntry::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.ip)
}
inline void RpbCoverageEntry::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.ip)
}
inline void RpbCoverageEntry::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.ip)
}
inline ::std::string* RpbCoverageEntry::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.ip)
  return ip_;
}
inline ::std::string* RpbCoverageEntry::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.ip)
}

// required uint32 port = 2;
inline bool RpbCoverageEntry::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpbCoverageEntry::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpbCoverageEntry::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpbCoverageEntry::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 RpbCoverageEntry::port() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.port)
  return port_;
}
inline void RpbCoverageEntry::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.port)
}

// optional bytes keyspace_desc = 3;
inline bool RpbCoverageEntry::has_keyspace_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpbCoverageEntry::set_has_keyspace_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpbCoverageEntry::clear_has_keyspace_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpbCoverageEntry::clear_keyspace_desc() {
  if (keyspace_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_->clear();
  }
  clear_has_keyspace_desc();
}
inline const ::std::string& RpbCoverageEntry::keyspace_desc() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.keyspace_desc)
  return *keyspace_desc_;
}
inline void RpbCoverageEntry::set_keyspace_desc(const ::std::string& value) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.keyspace_desc)
}
inline void RpbCoverageEntry::set_keyspace_desc(const char* value) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.keyspace_desc)
}
inline void RpbCoverageEntry::set_keyspace_desc(const void* value, size_t size) {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  keyspace_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.keyspace_desc)
}
inline ::std::string* RpbCoverageEntry::mutable_keyspace_desc() {
  set_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keyspace_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.keyspace_desc)
  return keyspace_desc_;
}
inline ::std::string* RpbCoverageEntry::release_keyspace_desc() {
  clear_has_keyspace_desc();
  if (keyspace_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keyspace_desc_;
    keyspace_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_keyspace_desc(::std::string* keyspace_desc) {
  if (keyspace_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keyspace_desc_;
  }
  if (keyspace_desc) {
    set_has_keyspace_desc();
    keyspace_desc_ = keyspace_desc;
  } else {
    clear_has_keyspace_desc();
    keyspace_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.keyspace_desc)
}

// required bytes cover_context = 4;
inline bool RpbCoverageEntry::has_cover_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpbCoverageEntry::set_has_cover_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpbCoverageEntry::clear_has_cover_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpbCoverageEntry::clear_cover_context() {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_->clear();
  }
  clear_has_cover_context();
}
inline const ::std::string& RpbCoverageEntry::cover_context() const {
  // @@protoc_insertion_point(field_get:RpbCoverageEntry.cover_context)
  return *cover_context_;
}
inline void RpbCoverageEntry::set_cover_context(const ::std::string& value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set:RpbCoverageEntry.cover_context)
}
inline void RpbCoverageEntry::set_cover_context(const char* value) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(value);
  // @@protoc_insertion_point(field_set_char:RpbCoverageEntry.cover_context)
}
inline void RpbCoverageEntry::set_cover_context(const void* value, size_t size) {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  cover_context_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RpbCoverageEntry.cover_context)
}
inline ::std::string* RpbCoverageEntry::mutable_cover_context() {
  set_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_context_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RpbCoverageEntry.cover_context)
  return cover_context_;
}
inline ::std::string* RpbCoverageEntry::release_cover_context() {
  clear_has_cover_context();
  if (cover_context_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_context_;
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RpbCoverageEntry::set_allocated_cover_context(::std::string* cover_context) {
  if (cover_context_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_context_;
  }
  if (cover_context) {
    set_has_cover_context();
    cover_context_ = cover_context;
  } else {
    clear_has_cover_context();
    cover_context_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RpbCoverageEntry.cover_context)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RpbIndexReq_IndexQueryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpbIndexReq_IndexQueryType>() {
  return ::RpbIndexReq_IndexQueryType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riak_5fkv_2eproto__INCLUDED
